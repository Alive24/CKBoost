// Generated by Molecule 0.9.0

use molecule :: prelude :: * ;
# [derive (Clone)] pub struct Uint32 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint32 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint32 :: new_unchecked (v) } } impl Uint32 { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint32Reader < 'r > { Uint32Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint32 { type Builder = Uint32Builder ; const NAME : & 'static str = "Uint32" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint32 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint32Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint32Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint32Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint32Reader < 'r > { pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint32Reader < 'r > { type Entity = Uint32 ; const NAME : & 'static str = "Uint32Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint32Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint32Builder (pub (crate) [Byte ; 4]) ; impl :: core :: fmt :: Debug for Uint32Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint32Builder { fn default () -> Self { Uint32Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint32Builder { pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 4] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } } impl molecule :: prelude :: Builder for Uint32Builder { type Entity = Uint32 ; const NAME : & 'static str = "Uint32Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint32 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 4usize] > for Uint32 { fn from (value : [Byte ; 4usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 4usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint32 > for [Byte ; 4usize] { # [track_caller] fn from (value : Uint32) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () ,] } } impl From < [u8 ; 4usize] > for Uint32 { fn from (value : [u8 ; 4usize]) -> Self { Uint32Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 4usize] > :: try_from (value) ? . into ()) } } impl From < Uint32 > for [u8 ; 4usize] { # [track_caller] fn from (value : Uint32) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint32Reader < 'a >> for & 'a [u8 ; 4usize] { # [track_caller] fn from (value : Uint32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint32Reader < 'a >> for & 'a [u8 ; 4usize] { # [track_caller] fn from (value : & 'a Uint32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint64 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint64 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint64 :: new_unchecked (v) } } impl Uint64 { const DEFAULT_VALUE : [u8 ; 8] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint64 { type Builder = Uint64Builder ; const NAME : & 'static str = "Uint64" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint64 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint64Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint64Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint64Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint64Reader < 'r > { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint64Reader < 'r > { type Entity = Uint64 ; const NAME : & 'static str = "Uint64Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint64Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint64Builder (pub (crate) [Byte ; 8]) ; impl :: core :: fmt :: Debug for Uint64Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint64Builder { fn default () -> Self { Uint64Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint64Builder { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 8] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } pub fn nth4 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [4] = v . into () ; self } pub fn nth5 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [5] = v . into () ; self } pub fn nth6 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [6] = v . into () ; self } pub fn nth7 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [7] = v . into () ; self } } impl molecule :: prelude :: Builder for Uint64Builder { type Entity = Uint64 ; const NAME : & 'static str = "Uint64Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint64 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 8usize] > for Uint64 { fn from (value : [Byte ; 8usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 8usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint64 > for [Byte ; 8usize] { # [track_caller] fn from (value : Uint64) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () ,] } } impl From < [u8 ; 8usize] > for Uint64 { fn from (value : [u8 ; 8usize]) -> Self { Uint64Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 8usize] > :: try_from (value) ? . into ()) } } impl From < Uint64 > for [u8 ; 8usize] { # [track_caller] fn from (value : Uint64) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : Uint64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : & 'a Uint64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint128 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint128 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint128 :: new_unchecked (v) } } impl Uint128 { const DEFAULT_VALUE : [u8 ; 16] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint128 { type Builder = Uint128Builder ; const NAME : & 'static str = "Uint128" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint128 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint128Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint128Reader < 'r > { pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint128Reader < 'r > { type Entity = Uint128 ; const NAME : & 'static str = "Uint128Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint128Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint128Builder (pub (crate) [Byte ; 16]) ; impl :: core :: fmt :: Debug for Uint128Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint128Builder { fn default () -> Self { Uint128Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint128Builder { pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 16] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } pub fn nth4 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [4] = v . into () ; self } pub fn nth5 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [5] = v . into () ; self } pub fn nth6 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [6] = v . into () ; self } pub fn nth7 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [7] = v . into () ; self } pub fn nth8 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [8] = v . into () ; self } pub fn nth9 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [9] = v . into () ; self } pub fn nth10 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [10] = v . into () ; self } pub fn nth11 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [11] = v . into () ; self } pub fn nth12 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [12] = v . into () ; self } pub fn nth13 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [13] = v . into () ; self } pub fn nth14 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [14] = v . into () ; self } pub fn nth15 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [15] = v . into () ; self } } impl molecule :: prelude :: Builder for Uint128Builder { type Entity = Uint128 ; const NAME : & 'static str = "Uint128Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint128 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 16usize] > for Uint128 { fn from (value : [Byte ; 16usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint128 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 16usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint128 > for [Byte ; 16usize] { # [track_caller] fn from (value : Uint128) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () ,] } } impl From < [u8 ; 16usize] > for Uint128 { fn from (value : [u8 ; 16usize]) -> Self { Uint128Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint128 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 16usize] > :: try_from (value) ? . into ()) } } impl From < Uint128 > for [u8 ; 16usize] { # [track_caller] fn from (value : Uint128) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint128Reader < 'a >> for & 'a [u8 ; 16usize] { # [track_caller] fn from (value : Uint128Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint128Reader < 'a >> for & 'a [u8 ; 16usize] { # [track_caller] fn from (value : & 'a Uint128Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Byte32 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Byte32 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32 :: new_unchecked (v) } } impl Byte32 { const DEFAULT_VALUE : [u8 ; 32] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32 { type Builder = Byte32Builder ; const NAME : & 'static str = "Byte32" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct Byte32Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Byte32Reader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32Reader < 'r > { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Byte32Builder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for Byte32Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Byte32Builder { fn default () -> Self { Byte32Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Byte32Builder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 32] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } pub fn nth4 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [4] = v . into () ; self } pub fn nth5 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [5] = v . into () ; self } pub fn nth6 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [6] = v . into () ; self } pub fn nth7 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [7] = v . into () ; self } pub fn nth8 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [8] = v . into () ; self } pub fn nth9 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [9] = v . into () ; self } pub fn nth10 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [10] = v . into () ; self } pub fn nth11 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [11] = v . into () ; self } pub fn nth12 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [12] = v . into () ; self } pub fn nth13 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [13] = v . into () ; self } pub fn nth14 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [14] = v . into () ; self } pub fn nth15 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [15] = v . into () ; self } pub fn nth16 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [16] = v . into () ; self } pub fn nth17 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [17] = v . into () ; self } pub fn nth18 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [18] = v . into () ; self } pub fn nth19 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [19] = v . into () ; self } pub fn nth20 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [20] = v . into () ; self } pub fn nth21 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [21] = v . into () ; self } pub fn nth22 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [22] = v . into () ; self } pub fn nth23 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [23] = v . into () ; self } pub fn nth24 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [24] = v . into () ; self } pub fn nth25 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [25] = v . into () ; self } pub fn nth26 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [26] = v . into () ; self } pub fn nth27 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [27] = v . into () ; self } pub fn nth28 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [28] = v . into () ; self } pub fn nth29 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [29] = v . into () ; self } pub fn nth30 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [30] = v . into () ; self } pub fn nth31 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [31] = v . into () ; self } } impl molecule :: prelude :: Builder for Byte32Builder { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 32usize] > for Byte32 { fn from (value : [Byte ; 32usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 32usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Byte32 > for [Byte ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () , value . nth16 () , value . nth17 () , value . nth18 () , value . nth19 () , value . nth20 () , value . nth21 () , value . nth22 () , value . nth23 () , value . nth24 () , value . nth25 () , value . nth26 () , value . nth27 () , value . nth28 () , value . nth29 () , value . nth30 () , value . nth31 () ,] } } impl From < [u8 ; 32usize] > for Byte32 { fn from (value : [u8 ; 32usize]) -> Self { Byte32Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 32usize] > :: try_from (value) ? . into ()) } } impl From < Byte32 > for [u8 ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : & 'a Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint256 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint256 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint256 :: new_unchecked (v) } } impl Uint256 { const DEFAULT_VALUE : [u8 ; 32] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint256Reader < 'r > { Uint256Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint256 { type Builder = Uint256Builder ; const NAME : & 'static str = "Uint256" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint256 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint256Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint256Reader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint256Reader < 'r > { type Entity = Uint256 ; const NAME : & 'static str = "Uint256Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint256Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint256Builder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for Uint256Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint256Builder { fn default () -> Self { Uint256Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint256Builder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 32] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } pub fn nth4 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [4] = v . into () ; self } pub fn nth5 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [5] = v . into () ; self } pub fn nth6 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [6] = v . into () ; self } pub fn nth7 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [7] = v . into () ; self } pub fn nth8 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [8] = v . into () ; self } pub fn nth9 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [9] = v . into () ; self } pub fn nth10 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [10] = v . into () ; self } pub fn nth11 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [11] = v . into () ; self } pub fn nth12 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [12] = v . into () ; self } pub fn nth13 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [13] = v . into () ; self } pub fn nth14 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [14] = v . into () ; self } pub fn nth15 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [15] = v . into () ; self } pub fn nth16 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [16] = v . into () ; self } pub fn nth17 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [17] = v . into () ; self } pub fn nth18 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [18] = v . into () ; self } pub fn nth19 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [19] = v . into () ; self } pub fn nth20 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [20] = v . into () ; self } pub fn nth21 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [21] = v . into () ; self } pub fn nth22 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [22] = v . into () ; self } pub fn nth23 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [23] = v . into () ; self } pub fn nth24 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [24] = v . into () ; self } pub fn nth25 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [25] = v . into () ; self } pub fn nth26 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [26] = v . into () ; self } pub fn nth27 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [27] = v . into () ; self } pub fn nth28 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [28] = v . into () ; self } pub fn nth29 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [29] = v . into () ; self } pub fn nth30 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [30] = v . into () ; self } pub fn nth31 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [31] = v . into () ; self } } impl molecule :: prelude :: Builder for Uint256Builder { type Entity = Uint256 ; const NAME : & 'static str = "Uint256Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint256 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 32usize] > for Uint256 { fn from (value : [Byte ; 32usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint256 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 32usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint256 > for [Byte ; 32usize] { # [track_caller] fn from (value : Uint256) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () , value . nth16 () , value . nth17 () , value . nth18 () , value . nth19 () , value . nth20 () , value . nth21 () , value . nth22 () , value . nth23 () , value . nth24 () , value . nth25 () , value . nth26 () , value . nth27 () , value . nth28 () , value . nth29 () , value . nth30 () , value . nth31 () ,] } } impl From < [u8 ; 32usize] > for Uint256 { fn from (value : [u8 ; 32usize]) -> Self { Uint256Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint256 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 32usize] > :: try_from (value) ? . into ()) } } impl From < Uint256 > for [u8 ; 32usize] { # [track_caller] fn from (value : Uint256) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint256Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : Uint256Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint256Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : & 'a Uint256Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Bytes (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Bytes { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Bytes :: new_unchecked (v) } } impl Bytes { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> BytesReader < 'r > { BytesReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bytes { type Builder = BytesBuilder ; const NAME : & 'static str = "Bytes" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bytes (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > BytesReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesReader < 'r > { type Entity = Bytes ; const NAME : & 'static str = "BytesReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesBuilder (pub (crate) Vec < Byte >) ; impl BytesBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Byte > where T : :: core :: convert :: Into < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for BytesBuilder { type Entity = Bytes ; const NAME : & 'static str = "BytesBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bytes :: new_unchecked (inner . into ()) } }
pub struct BytesIterator (Bytes , usize , usize) ; impl :: core :: iter :: Iterator for BytesIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Bytes { type Item = Byte ; type IntoIter = BytesIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesIterator (self , 0 , len) } }
impl :: core :: iter :: FromIterator < Byte > for Bytes { fn from_iter < T : IntoIterator < Item = Byte >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Byte >> for Bytes { fn from (v : Vec < Byte >) -> Self { Self :: new_builder () . set (v) . build () } } impl :: core :: iter :: FromIterator < u8 > for Bytes { fn from_iter < T : IntoIterator < Item = u8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter . into_iter () . map (Into :: into)) . build () } } impl From < Vec < u8 >> for Bytes { fn from (v : Vec < u8 >) -> Self { Self :: new_builder () . set (v . into_iter () . map (Into :: into) . collect ()) . build () } }
# [derive (Clone)] pub struct BytesOpt (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl :: core :: default :: Default for BytesOpt { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BytesOpt :: new_unchecked (v) } } impl BytesOpt { const DEFAULT_VALUE : [u8 ; 0] = [] ; pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < Bytes > { if self . is_none () { None } else { Some (Bytes :: new_unchecked (self . 0 . clone ())) } } pub fn as_reader < 'r > (& 'r self) -> BytesOptReader < 'r > { BytesOptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BytesOpt { type Builder = BytesOptBuilder ; const NAME : & 'static str = "BytesOpt" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BytesOpt (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set (self . to_opt ()) } }
# [derive (Clone , Copy)] pub struct BytesOptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl < 'r > BytesOptReader < 'r > { pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < BytesReader < 'r > > { if self . is_none () { None } else { Some (BytesReader :: new_unchecked (self . as_slice ())) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesOptReader < 'r > { type Entity = BytesOpt ; const NAME : & 'static str = "BytesOptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesOptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { if ! slice . is_empty () { BytesReader :: verify (& slice [..] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesOptBuilder (pub (crate) Option < Bytes >) ; impl BytesOptBuilder { pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Option < Bytes >> { self . 0 = v . into () ; self } } impl molecule :: prelude :: Builder for BytesOptBuilder { type Entity = BytesOpt ; const NAME : & 'static str = "BytesOptBuilder" ; fn expected_length (& self) -> usize { self . 0 . as_ref () . map (| ref inner | inner . as_slice () . len ()) . unwrap_or (0) } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { self . 0 . as_ref () . map (| ref inner | writer . write_all (inner . as_slice ())) . unwrap_or (Ok (())) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BytesOpt :: new_unchecked (inner . into ()) } }
impl From < Bytes > for BytesOpt { fn from (value : Bytes) -> Self { Self :: new_builder () . set (Some (value)) . build () } }
# [derive (Clone)] pub struct BytesOptVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BytesOptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BytesOptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BytesOptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for BytesOptVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BytesOptVec :: new_unchecked (v) } } impl BytesOptVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < BytesOpt > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> BytesOpt { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { BytesOpt :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; BytesOpt :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> BytesOptVecReader < 'r > { BytesOptVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BytesOptVec { type Builder = BytesOptVecBuilder ; const NAME : & 'static str = "BytesOptVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BytesOptVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesOptVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesOptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesOptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesOptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > BytesOptVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < BytesOptReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> BytesOptReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { BytesOptReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; BytesOptReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesOptVecReader < 'r > { type Entity = BytesOptVec ; const NAME : & 'static str = "BytesOptVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesOptVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; BytesOptReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesOptVecBuilder (pub (crate) Vec < BytesOpt >) ; impl BytesOptVecBuilder { pub fn set (mut self , v : Vec < BytesOpt >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesOpt > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = BytesOpt >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < BytesOpt > where T : :: core :: convert :: Into < BytesOpt > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for BytesOptVecBuilder { type Entity = BytesOptVec ; const NAME : & 'static str = "BytesOptVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BytesOptVec :: new_unchecked (inner . into ()) } }
pub struct BytesOptVecIterator (BytesOptVec , usize , usize) ; impl :: core :: iter :: Iterator for BytesOptVecIterator { type Item = BytesOpt ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesOptVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for BytesOptVec { type Item = BytesOpt ; type IntoIter = BytesOptVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesOptVecIterator (self , 0 , len) } } impl < 'r > BytesOptVecReader < 'r > { pub fn iter < 't > (& 't self) -> BytesOptVecReaderIterator < 't , 'r > { BytesOptVecReaderIterator (& self , 0 , self . len ()) } } pub struct BytesOptVecReaderIterator < 't , 'r > (& 't BytesOptVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for BytesOptVecReaderIterator < 't , 'r > { type Item = BytesOptReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for BytesOptVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < BytesOpt > for BytesOptVec { fn from_iter < T : IntoIterator < Item = BytesOpt >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < BytesOpt >> for BytesOptVec { fn from (v : Vec < BytesOpt >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct BytesVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for BytesVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BytesVec :: new_unchecked (v) } } impl BytesVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Bytes > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Bytes { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Bytes :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> BytesVecReader < 'r > { BytesVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BytesVec { type Builder = BytesVecBuilder ; const NAME : & 'static str = "BytesVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BytesVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > BytesVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < BytesReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> BytesReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesVecReader < 'r > { type Entity = BytesVec ; const NAME : & 'static str = "BytesVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; BytesReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesVecBuilder (pub (crate) Vec < Bytes >) ; impl BytesVecBuilder { pub fn set (mut self , v : Vec < Bytes >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Bytes > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Bytes >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Bytes > where T : :: core :: convert :: Into < Bytes > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for BytesVecBuilder { type Entity = BytesVec ; const NAME : & 'static str = "BytesVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BytesVec :: new_unchecked (inner . into ()) } }
pub struct BytesVecIterator (BytesVec , usize , usize) ; impl :: core :: iter :: Iterator for BytesVecIterator { type Item = Bytes ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for BytesVec { type Item = Bytes ; type IntoIter = BytesVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesVecIterator (self , 0 , len) } } impl < 'r > BytesVecReader < 'r > { pub fn iter < 't > (& 't self) -> BytesVecReaderIterator < 't , 'r > { BytesVecReaderIterator (& self , 0 , self . len ()) } } pub struct BytesVecReaderIterator < 't , 'r > (& 't BytesVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for BytesVecReaderIterator < 't , 'r > { type Item = BytesReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for BytesVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Bytes > for BytesVec { fn from_iter < T : IntoIterator < Item = Bytes >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Bytes >> for BytesVec { fn from (v : Vec < Bytes >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct Byte32Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Byte32Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32Vec :: new_unchecked (v) } } impl Byte32Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte32 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte32 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Byte32VecReader < 'r > { Byte32VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32Vec { type Builder = Byte32VecBuilder ; const NAME : & 'static str = "Byte32Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Byte32VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Byte32VecReader < 'r > { pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte32Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte32Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32VecReader < 'r > { type Entity = Byte32Vec ; const NAME : & 'static str = "Byte32VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Byte32VecBuilder (pub (crate) Vec < Byte32 >) ; impl Byte32VecBuilder { pub const ITEM_SIZE : usize = 32 ; pub fn set (mut self , v : Vec < Byte32 >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte32 >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Byte32 > where T : :: core :: convert :: Into < Byte32 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for Byte32VecBuilder { type Entity = Byte32Vec ; const NAME : & 'static str = "Byte32VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32Vec :: new_unchecked (inner . into ()) } }
pub struct Byte32VecIterator (Byte32Vec , usize , usize) ; impl :: core :: iter :: Iterator for Byte32VecIterator { type Item = Byte32 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Byte32VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Byte32Vec { type Item = Byte32 ; type IntoIter = Byte32VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Byte32VecIterator (self , 0 , len) } } impl < 'r > Byte32VecReader < 'r > { pub fn iter < 't > (& 't self) -> Byte32VecReaderIterator < 't , 'r > { Byte32VecReaderIterator (& self , 0 , self . len ()) } } pub struct Byte32VecReaderIterator < 't , 'r > (& 't Byte32VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Byte32VecReaderIterator < 't , 'r > { type Item = Byte32Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Byte32VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Byte32 > for Byte32Vec { fn from_iter < T : IntoIterator < Item = Byte32 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Byte32 >> for Byte32Vec { fn from (v : Vec < Byte32 >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct ScriptOpt (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ScriptOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ScriptOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ScriptOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl :: core :: default :: Default for ScriptOpt { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ScriptOpt :: new_unchecked (v) } } impl ScriptOpt { const DEFAULT_VALUE : [u8 ; 0] = [] ; pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < Script > { if self . is_none () { None } else { Some (Script :: new_unchecked (self . 0 . clone ())) } } pub fn as_reader < 'r > (& 'r self) -> ScriptOptReader < 'r > { ScriptOptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ScriptOpt { type Builder = ScriptOptBuilder ; const NAME : & 'static str = "ScriptOpt" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ScriptOpt (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptOptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptOptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set (self . to_opt ()) } }
# [derive (Clone , Copy)] pub struct ScriptOptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl < 'r > ScriptOptReader < 'r > { pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < ScriptReader < 'r > > { if self . is_none () { None } else { Some (ScriptReader :: new_unchecked (self . as_slice ())) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptOptReader < 'r > { type Entity = ScriptOpt ; const NAME : & 'static str = "ScriptOptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptOptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { if ! slice . is_empty () { ScriptReader :: verify (& slice [..] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptOptBuilder (pub (crate) Option < Script >) ; impl ScriptOptBuilder { pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Option < Script >> { self . 0 = v . into () ; self } } impl molecule :: prelude :: Builder for ScriptOptBuilder { type Entity = ScriptOpt ; const NAME : & 'static str = "ScriptOptBuilder" ; fn expected_length (& self) -> usize { self . 0 . as_ref () . map (| ref inner | inner . as_slice () . len ()) . unwrap_or (0) } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { self . 0 . as_ref () . map (| ref inner | writer . write_all (inner . as_slice ())) . unwrap_or (Ok (())) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ScriptOpt :: new_unchecked (inner . into ()) } }
impl From < Script > for ScriptOpt { fn from (value : Script) -> Self { Self :: new_builder () . set (Some (value)) . build () } }
# [derive (Clone)] pub struct ProposalShortId (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ProposalShortId { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ProposalShortId { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ProposalShortId { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for ProposalShortId { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ProposalShortId :: new_unchecked (v) } } impl ProposalShortId { const DEFAULT_VALUE : [u8 ; 10] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 10 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 10 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> ProposalShortIdReader < 'r > { ProposalShortIdReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ProposalShortId { type Builder = ProposalShortIdBuilder ; const NAME : & 'static str = "ProposalShortId" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ProposalShortId (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProposalShortIdReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProposalShortIdReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () ,]) } }
# [derive (Clone , Copy)] pub struct ProposalShortIdReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ProposalShortIdReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ProposalShortIdReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ProposalShortIdReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > ProposalShortIdReader < 'r > { pub const TOTAL_SIZE : usize = 10 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 10 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for ProposalShortIdReader < 'r > { type Entity = ProposalShortId ; const NAME : & 'static str = "ProposalShortIdReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ProposalShortIdReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct ProposalShortIdBuilder (pub (crate) [Byte ; 10]) ; impl :: core :: fmt :: Debug for ProposalShortIdBuilder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for ProposalShortIdBuilder { fn default () -> Self { ProposalShortIdBuilder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl ProposalShortIdBuilder { pub const TOTAL_SIZE : usize = 10 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 10 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 10] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } pub fn nth1 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [1] = v . into () ; self } pub fn nth2 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [2] = v . into () ; self } pub fn nth3 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [3] = v . into () ; self } pub fn nth4 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [4] = v . into () ; self } pub fn nth5 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [5] = v . into () ; self } pub fn nth6 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [6] = v . into () ; self } pub fn nth7 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [7] = v . into () ; self } pub fn nth8 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [8] = v . into () ; self } pub fn nth9 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [9] = v . into () ; self } } impl molecule :: prelude :: Builder for ProposalShortIdBuilder { type Entity = ProposalShortId ; const NAME : & 'static str = "ProposalShortIdBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ProposalShortId :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 10usize] > for ProposalShortId { fn from (value : [Byte ; 10usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for ProposalShortId { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 10usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < ProposalShortId > for [Byte ; 10usize] { # [track_caller] fn from (value : ProposalShortId) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () ,] } } impl From < [u8 ; 10usize] > for ProposalShortId { fn from (value : [u8 ; 10usize]) -> Self { ProposalShortIdReader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for ProposalShortId { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 10usize] > :: try_from (value) ? . into ()) } } impl From < ProposalShortId > for [u8 ; 10usize] { # [track_caller] fn from (value : ProposalShortId) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < ProposalShortIdReader < 'a >> for & 'a [u8 ; 10usize] { # [track_caller] fn from (value : ProposalShortIdReader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a ProposalShortIdReader < 'a >> for & 'a [u8 ; 10usize] { # [track_caller] fn from (value : & 'a ProposalShortIdReader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct UncleBlockVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UncleBlockVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UncleBlockVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UncleBlockVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for UncleBlockVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UncleBlockVec :: new_unchecked (v) } } impl UncleBlockVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UncleBlock > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UncleBlock { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UncleBlock :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UncleBlock :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> UncleBlockVecReader < 'r > { UncleBlockVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UncleBlockVec { type Builder = UncleBlockVecBuilder ; const NAME : & 'static str = "UncleBlockVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UncleBlockVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UncleBlockVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UncleBlockVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct UncleBlockVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UncleBlockVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UncleBlockVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UncleBlockVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > UncleBlockVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UncleBlockReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UncleBlockReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UncleBlockReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UncleBlockReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UncleBlockVecReader < 'r > { type Entity = UncleBlockVec ; const NAME : & 'static str = "UncleBlockVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UncleBlockVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; UncleBlockReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UncleBlockVecBuilder (pub (crate) Vec < UncleBlock >) ; impl UncleBlockVecBuilder { pub fn set (mut self , v : Vec < UncleBlock >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UncleBlock > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = UncleBlock >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < UncleBlock > where T : :: core :: convert :: Into < UncleBlock > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for UncleBlockVecBuilder { type Entity = UncleBlockVec ; const NAME : & 'static str = "UncleBlockVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UncleBlockVec :: new_unchecked (inner . into ()) } }
pub struct UncleBlockVecIterator (UncleBlockVec , usize , usize) ; impl :: core :: iter :: Iterator for UncleBlockVecIterator { type Item = UncleBlock ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for UncleBlockVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for UncleBlockVec { type Item = UncleBlock ; type IntoIter = UncleBlockVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; UncleBlockVecIterator (self , 0 , len) } } impl < 'r > UncleBlockVecReader < 'r > { pub fn iter < 't > (& 't self) -> UncleBlockVecReaderIterator < 't , 'r > { UncleBlockVecReaderIterator (& self , 0 , self . len ()) } } pub struct UncleBlockVecReaderIterator < 't , 'r > (& 't UncleBlockVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for UncleBlockVecReaderIterator < 't , 'r > { type Item = UncleBlockReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for UncleBlockVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < UncleBlock > for UncleBlockVec { fn from_iter < T : IntoIterator < Item = UncleBlock >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < UncleBlock >> for UncleBlockVec { fn from (v : Vec < UncleBlock >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct TransactionVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for TransactionVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for TransactionVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for TransactionVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for TransactionVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; TransactionVec :: new_unchecked (v) } } impl TransactionVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Transaction > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Transaction { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Transaction :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Transaction :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> TransactionVecReader < 'r > { TransactionVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for TransactionVec { type Builder = TransactionVecBuilder ; const NAME : & 'static str = "TransactionVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { TransactionVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TransactionVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TransactionVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct TransactionVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TransactionVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TransactionVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TransactionVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > TransactionVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < TransactionReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> TransactionReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { TransactionReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; TransactionReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TransactionVecReader < 'r > { type Entity = TransactionVec ; const NAME : & 'static str = "TransactionVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TransactionVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; TransactionReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TransactionVecBuilder (pub (crate) Vec < Transaction >) ; impl TransactionVecBuilder { pub fn set (mut self , v : Vec < Transaction >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Transaction > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Transaction >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Transaction > where T : :: core :: convert :: Into < Transaction > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for TransactionVecBuilder { type Entity = TransactionVec ; const NAME : & 'static str = "TransactionVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; TransactionVec :: new_unchecked (inner . into ()) } }
pub struct TransactionVecIterator (TransactionVec , usize , usize) ; impl :: core :: iter :: Iterator for TransactionVecIterator { type Item = Transaction ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for TransactionVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for TransactionVec { type Item = Transaction ; type IntoIter = TransactionVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; TransactionVecIterator (self , 0 , len) } } impl < 'r > TransactionVecReader < 'r > { pub fn iter < 't > (& 't self) -> TransactionVecReaderIterator < 't , 'r > { TransactionVecReaderIterator (& self , 0 , self . len ()) } } pub struct TransactionVecReaderIterator < 't , 'r > (& 't TransactionVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for TransactionVecReaderIterator < 't , 'r > { type Item = TransactionReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for TransactionVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Transaction > for TransactionVec { fn from_iter < T : IntoIterator < Item = Transaction >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Transaction >> for TransactionVec { fn from (v : Vec < Transaction >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct ProposalShortIdVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ProposalShortIdVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ProposalShortIdVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ProposalShortIdVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for ProposalShortIdVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ProposalShortIdVec :: new_unchecked (v) } } impl ProposalShortIdVec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ProposalShortId > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ProposalShortId { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ProposalShortId :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> ProposalShortIdVecReader < 'r > { ProposalShortIdVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ProposalShortIdVec { type Builder = ProposalShortIdVecBuilder ; const NAME : & 'static str = "ProposalShortIdVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ProposalShortIdVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProposalShortIdVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProposalShortIdVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct ProposalShortIdVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ProposalShortIdVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ProposalShortIdVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ProposalShortIdVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > ProposalShortIdVecReader < 'r > { pub const ITEM_SIZE : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ProposalShortIdReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ProposalShortIdReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ProposalShortIdReader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for ProposalShortIdVecReader < 'r > { type Entity = ProposalShortIdVec ; const NAME : & 'static str = "ProposalShortIdVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ProposalShortIdVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ProposalShortIdVecBuilder (pub (crate) Vec < ProposalShortId >) ; impl ProposalShortIdVecBuilder { pub const ITEM_SIZE : usize = 10 ; pub fn set (mut self , v : Vec < ProposalShortId >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ProposalShortId > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = ProposalShortId >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < ProposalShortId > where T : :: core :: convert :: Into < ProposalShortId > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for ProposalShortIdVecBuilder { type Entity = ProposalShortIdVec ; const NAME : & 'static str = "ProposalShortIdVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ProposalShortIdVec :: new_unchecked (inner . into ()) } }
pub struct ProposalShortIdVecIterator (ProposalShortIdVec , usize , usize) ; impl :: core :: iter :: Iterator for ProposalShortIdVecIterator { type Item = ProposalShortId ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for ProposalShortIdVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ProposalShortIdVec { type Item = ProposalShortId ; type IntoIter = ProposalShortIdVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; ProposalShortIdVecIterator (self , 0 , len) } } impl < 'r > ProposalShortIdVecReader < 'r > { pub fn iter < 't > (& 't self) -> ProposalShortIdVecReaderIterator < 't , 'r > { ProposalShortIdVecReaderIterator (& self , 0 , self . len ()) } } pub struct ProposalShortIdVecReaderIterator < 't , 'r > (& 't ProposalShortIdVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ProposalShortIdVecReaderIterator < 't , 'r > { type Item = ProposalShortIdReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ProposalShortIdVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < ProposalShortId > for ProposalShortIdVec { fn from_iter < T : IntoIterator < Item = ProposalShortId >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < ProposalShortId >> for ProposalShortIdVec { fn from (v : Vec < ProposalShortId >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct CellDepVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellDepVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellDepVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellDepVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for CellDepVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellDepVec :: new_unchecked (v) } } impl CellDepVec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 37 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellDep > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellDep { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; CellDep :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> CellDepVecReader < 'r > { CellDepVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellDepVec { type Builder = CellDepVecBuilder ; const NAME : & 'static str = "CellDepVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellDepVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellDepVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellDepVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct CellDepVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellDepVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellDepVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellDepVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > CellDepVecReader < 'r > { pub const ITEM_SIZE : usize = 37 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellDepReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellDepReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; CellDepReader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellDepVecReader < 'r > { type Entity = CellDepVec ; const NAME : & 'static str = "CellDepVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellDepVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellDepVecBuilder (pub (crate) Vec < CellDep >) ; impl CellDepVecBuilder { pub const ITEM_SIZE : usize = 37 ; pub fn set (mut self , v : Vec < CellDep >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellDep > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = CellDep >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < CellDep > where T : :: core :: convert :: Into < CellDep > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for CellDepVecBuilder { type Entity = CellDepVec ; const NAME : & 'static str = "CellDepVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellDepVec :: new_unchecked (inner . into ()) } }
pub struct CellDepVecIterator (CellDepVec , usize , usize) ; impl :: core :: iter :: Iterator for CellDepVecIterator { type Item = CellDep ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for CellDepVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for CellDepVec { type Item = CellDep ; type IntoIter = CellDepVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; CellDepVecIterator (self , 0 , len) } } impl < 'r > CellDepVecReader < 'r > { pub fn iter < 't > (& 't self) -> CellDepVecReaderIterator < 't , 'r > { CellDepVecReaderIterator (& self , 0 , self . len ()) } } pub struct CellDepVecReaderIterator < 't , 'r > (& 't CellDepVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for CellDepVecReaderIterator < 't , 'r > { type Item = CellDepReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for CellDepVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < CellDep > for CellDepVec { fn from_iter < T : IntoIterator < Item = CellDep >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < CellDep >> for CellDepVec { fn from (v : Vec < CellDep >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct CellInputVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellInputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellInputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellInputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for CellInputVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellInputVec :: new_unchecked (v) } } impl CellInputVec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 44 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellInput > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellInput { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; CellInput :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> CellInputVecReader < 'r > { CellInputVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellInputVec { type Builder = CellInputVecBuilder ; const NAME : & 'static str = "CellInputVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellInputVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellInputVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellInputVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct CellInputVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellInputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellInputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellInputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > CellInputVecReader < 'r > { pub const ITEM_SIZE : usize = 44 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellInputReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellInputReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; CellInputReader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellInputVecReader < 'r > { type Entity = CellInputVec ; const NAME : & 'static str = "CellInputVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellInputVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellInputVecBuilder (pub (crate) Vec < CellInput >) ; impl CellInputVecBuilder { pub const ITEM_SIZE : usize = 44 ; pub fn set (mut self , v : Vec < CellInput >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellInput > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = CellInput >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < CellInput > where T : :: core :: convert :: Into < CellInput > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for CellInputVecBuilder { type Entity = CellInputVec ; const NAME : & 'static str = "CellInputVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellInputVec :: new_unchecked (inner . into ()) } }
pub struct CellInputVecIterator (CellInputVec , usize , usize) ; impl :: core :: iter :: Iterator for CellInputVecIterator { type Item = CellInput ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for CellInputVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for CellInputVec { type Item = CellInput ; type IntoIter = CellInputVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; CellInputVecIterator (self , 0 , len) } } impl < 'r > CellInputVecReader < 'r > { pub fn iter < 't > (& 't self) -> CellInputVecReaderIterator < 't , 'r > { CellInputVecReaderIterator (& self , 0 , self . len ()) } } pub struct CellInputVecReaderIterator < 't , 'r > (& 't CellInputVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for CellInputVecReaderIterator < 't , 'r > { type Item = CellInputReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for CellInputVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < CellInput > for CellInputVec { fn from_iter < T : IntoIterator < Item = CellInput >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < CellInput >> for CellInputVec { fn from (v : Vec < CellInput >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct CellOutputVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellOutputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellOutputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellOutputVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for CellOutputVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellOutputVec :: new_unchecked (v) } } impl CellOutputVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellOutput > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellOutput { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { CellOutput :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; CellOutput :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> CellOutputVecReader < 'r > { CellOutputVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellOutputVec { type Builder = CellOutputVecBuilder ; const NAME : & 'static str = "CellOutputVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellOutputVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellOutputVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellOutputVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct CellOutputVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellOutputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellOutputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellOutputVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > CellOutputVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CellOutputReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CellOutputReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { CellOutputReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; CellOutputReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellOutputVecReader < 'r > { type Entity = CellOutputVec ; const NAME : & 'static str = "CellOutputVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellOutputVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; CellOutputReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellOutputVecBuilder (pub (crate) Vec < CellOutput >) ; impl CellOutputVecBuilder { pub fn set (mut self , v : Vec < CellOutput >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellOutput > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = CellOutput >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < CellOutput > where T : :: core :: convert :: Into < CellOutput > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for CellOutputVecBuilder { type Entity = CellOutputVec ; const NAME : & 'static str = "CellOutputVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellOutputVec :: new_unchecked (inner . into ()) } }
pub struct CellOutputVecIterator (CellOutputVec , usize , usize) ; impl :: core :: iter :: Iterator for CellOutputVecIterator { type Item = CellOutput ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for CellOutputVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for CellOutputVec { type Item = CellOutput ; type IntoIter = CellOutputVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; CellOutputVecIterator (self , 0 , len) } } impl < 'r > CellOutputVecReader < 'r > { pub fn iter < 't > (& 't self) -> CellOutputVecReaderIterator < 't , 'r > { CellOutputVecReaderIterator (& self , 0 , self . len ()) } } pub struct CellOutputVecReaderIterator < 't , 'r > (& 't CellOutputVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for CellOutputVecReaderIterator < 't , 'r > { type Item = CellOutputReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for CellOutputVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < CellOutput > for CellOutputVec { fn from_iter < T : IntoIterator < Item = CellOutput >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < CellOutput >> for CellOutputVec { fn from (v : Vec < CellOutput >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct Script (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "code_hash" , self . code_hash ()) ? ; write ! (f , ", {}: {}" , "hash_type" , self . hash_type ()) ? ; write ! (f , ", {}: {}" , "args" , self . args ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Script { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Script :: new_unchecked (v) } } impl Script { const DEFAULT_VALUE : [u8 ; 53] = [53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn hash_type (& self) -> Byte { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn args (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ScriptReader < 'r > { ScriptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Script { type Builder = ScriptBuilder ; const NAME : & 'static str = "Script" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Script (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . code_hash (self . code_hash ()) . hash_type (self . hash_type ()) . args (self . args ()) } }
# [derive (Clone , Copy)] pub struct ScriptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "code_hash" , self . code_hash ()) ? ; write ! (f , ", {}: {}" , "hash_type" , self . hash_type ()) ? ; write ! (f , ", {}: {}" , "args" , self . args ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ScriptReader < 'r > { pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn hash_type (& self) -> ByteReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn args (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptReader < 'r > { type Entity = Script ; const NAME : & 'static str = "ScriptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; ByteReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; BytesReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptBuilder { pub (crate) code_hash : Byte32 , pub (crate) hash_type : Byte , pub (crate) args : Bytes , } impl ScriptBuilder { pub const FIELD_COUNT : usize = 3 ; pub fn code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . code_hash = v . into () ; self } pub fn hash_type < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . hash_type = v . into () ; self } pub fn args < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Bytes > { self . args = v . into () ; self } } impl molecule :: prelude :: Builder for ScriptBuilder { type Entity = Script ; const NAME : & 'static str = "ScriptBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . code_hash . as_slice () . len () + self . hash_type . as_slice () . len () + self . args . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . hash_type . as_slice () . len () ; offsets . push (total_size) ; total_size += self . args . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . code_hash . as_slice ()) ? ; writer . write_all (self . hash_type . as_slice ()) ? ; writer . write_all (self . args . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Script :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct OutPoint (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for OutPoint { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for OutPoint { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for OutPoint { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "tx_hash" , self . tx_hash ()) ? ; write ! (f , ", {}: {}" , "index" , self . index ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for OutPoint { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; OutPoint :: new_unchecked (v) } } impl OutPoint { const DEFAULT_VALUE : [u8 ; 36] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 36 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 4 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn tx_hash (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (0 .. 32)) } pub fn index (& self) -> Uint32 { Uint32 :: new_unchecked (self . 0 . slice (32 .. 36)) } pub fn as_reader < 'r > (& 'r self) -> OutPointReader < 'r > { OutPointReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for OutPoint { type Builder = OutPointBuilder ; const NAME : & 'static str = "OutPoint" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { OutPoint (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { OutPointReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { OutPointReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . tx_hash (self . tx_hash ()) . index (self . index ()) } }
# [derive (Clone , Copy)] pub struct OutPointReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for OutPointReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for OutPointReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for OutPointReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "tx_hash" , self . tx_hash ()) ? ; write ! (f , ", {}: {}" , "index" , self . index ()) ? ; write ! (f , " }}") } } impl < 'r > OutPointReader < 'r > { pub const TOTAL_SIZE : usize = 36 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 4 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn tx_hash (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [0 .. 32]) } pub fn index (& self) -> Uint32Reader < 'r > { Uint32Reader :: new_unchecked (& self . as_slice () [32 .. 36]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for OutPointReader < 'r > { type Entity = OutPoint ; const NAME : & 'static str = "OutPointReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { OutPointReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct OutPointBuilder { pub (crate) tx_hash : Byte32 , pub (crate) index : Uint32 , } impl OutPointBuilder { pub const TOTAL_SIZE : usize = 36 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 4 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn tx_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . tx_hash = v . into () ; self } pub fn index < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . index = v . into () ; self } } impl molecule :: prelude :: Builder for OutPointBuilder { type Entity = OutPoint ; const NAME : & 'static str = "OutPointBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . tx_hash . as_slice ()) ? ; writer . write_all (self . index . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; OutPoint :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CellInput (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellInput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellInput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellInput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "since" , self . since ()) ? ; write ! (f , ", {}: {}" , "previous_output" , self . previous_output ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for CellInput { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellInput :: new_unchecked (v) } } impl CellInput { const DEFAULT_VALUE : [u8 ; 44] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 44 ; pub const FIELD_SIZES : [usize ; 2] = [8 , 36 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn since (& self) -> Uint64 { Uint64 :: new_unchecked (self . 0 . slice (0 .. 8)) } pub fn previous_output (& self) -> OutPoint { OutPoint :: new_unchecked (self . 0 . slice (8 .. 44)) } pub fn as_reader < 'r > (& 'r self) -> CellInputReader < 'r > { CellInputReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellInput { type Builder = CellInputBuilder ; const NAME : & 'static str = "CellInput" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellInput (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellInputReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellInputReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . since (self . since ()) . previous_output (self . previous_output ()) } }
# [derive (Clone , Copy)] pub struct CellInputReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellInputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellInputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellInputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "since" , self . since ()) ? ; write ! (f , ", {}: {}" , "previous_output" , self . previous_output ()) ? ; write ! (f , " }}") } } impl < 'r > CellInputReader < 'r > { pub const TOTAL_SIZE : usize = 44 ; pub const FIELD_SIZES : [usize ; 2] = [8 , 36 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn since (& self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (& self . as_slice () [0 .. 8]) } pub fn previous_output (& self) -> OutPointReader < 'r > { OutPointReader :: new_unchecked (& self . as_slice () [8 .. 44]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellInputReader < 'r > { type Entity = CellInput ; const NAME : & 'static str = "CellInputReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellInputReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellInputBuilder { pub (crate) since : Uint64 , pub (crate) previous_output : OutPoint , } impl CellInputBuilder { pub const TOTAL_SIZE : usize = 44 ; pub const FIELD_SIZES : [usize ; 2] = [8 , 36 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn since < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . since = v . into () ; self } pub fn previous_output < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < OutPoint > { self . previous_output = v . into () ; self } } impl molecule :: prelude :: Builder for CellInputBuilder { type Entity = CellInput ; const NAME : & 'static str = "CellInputBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . since . as_slice ()) ? ; writer . write_all (self . previous_output . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellInput :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CellOutput (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellOutput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellOutput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellOutput { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "capacity" , self . capacity ()) ? ; write ! (f , ", {}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "type_" , self . type_ ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for CellOutput { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellOutput :: new_unchecked (v) } } impl CellOutput { const DEFAULT_VALUE : [u8 ; 77] = [77 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 77 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn capacity (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn lock (& self) -> Script { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Script :: new_unchecked (self . 0 . slice (start .. end)) } pub fn type_ (& self) -> ScriptOpt { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; ScriptOpt :: new_unchecked (self . 0 . slice (start .. end)) } else { ScriptOpt :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> CellOutputReader < 'r > { CellOutputReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellOutput { type Builder = CellOutputBuilder ; const NAME : & 'static str = "CellOutput" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellOutput (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellOutputReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellOutputReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . capacity (self . capacity ()) . lock (self . lock ()) . type_ (self . type_ ()) } }
# [derive (Clone , Copy)] pub struct CellOutputReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellOutputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellOutputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellOutputReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "capacity" , self . capacity ()) ? ; write ! (f , ", {}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "type_" , self . type_ ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > CellOutputReader < 'r > { pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn capacity (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn lock (& self) -> ScriptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ScriptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn type_ (& self) -> ScriptOptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; ScriptOptReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ScriptOptReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellOutputReader < 'r > { type Entity = CellOutput ; const NAME : & 'static str = "CellOutputReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellOutputReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint64Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; ScriptReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; ScriptOptReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellOutputBuilder { pub (crate) capacity : Uint64 , pub (crate) lock : Script , pub (crate) type_ : ScriptOpt , } impl CellOutputBuilder { pub const FIELD_COUNT : usize = 3 ; pub fn capacity < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . capacity = v . into () ; self } pub fn lock < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Script > { self . lock = v . into () ; self } pub fn type_ < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ScriptOpt > { self . type_ = v . into () ; self } } impl molecule :: prelude :: Builder for CellOutputBuilder { type Entity = CellOutput ; const NAME : & 'static str = "CellOutputBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . capacity . as_slice () . len () + self . lock . as_slice () . len () + self . type_ . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . capacity . as_slice () . len () ; offsets . push (total_size) ; total_size += self . lock . as_slice () . len () ; offsets . push (total_size) ; total_size += self . type_ . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . capacity . as_slice ()) ? ; writer . write_all (self . lock . as_slice ()) ? ; writer . write_all (self . type_ . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellOutput :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CellDep (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellDep { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellDep { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellDep { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "out_point" , self . out_point ()) ? ; write ! (f , ", {}: {}" , "dep_type" , self . dep_type ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for CellDep { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellDep :: new_unchecked (v) } } impl CellDep { const DEFAULT_VALUE : [u8 ; 37] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 37 ; pub const FIELD_SIZES : [usize ; 2] = [36 , 1 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn out_point (& self) -> OutPoint { OutPoint :: new_unchecked (self . 0 . slice (0 .. 36)) } pub fn dep_type (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (36 .. 37)) } pub fn as_reader < 'r > (& 'r self) -> CellDepReader < 'r > { CellDepReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellDep { type Builder = CellDepBuilder ; const NAME : & 'static str = "CellDep" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellDep (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellDepReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellDepReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . out_point (self . out_point ()) . dep_type (self . dep_type ()) } }
# [derive (Clone , Copy)] pub struct CellDepReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellDepReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellDepReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellDepReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "out_point" , self . out_point ()) ? ; write ! (f , ", {}: {}" , "dep_type" , self . dep_type ()) ? ; write ! (f , " }}") } } impl < 'r > CellDepReader < 'r > { pub const TOTAL_SIZE : usize = 37 ; pub const FIELD_SIZES : [usize ; 2] = [36 , 1 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn out_point (& self) -> OutPointReader < 'r > { OutPointReader :: new_unchecked (& self . as_slice () [0 .. 36]) } pub fn dep_type (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [36 .. 37]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellDepReader < 'r > { type Entity = CellDep ; const NAME : & 'static str = "CellDepReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellDepReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellDepBuilder { pub (crate) out_point : OutPoint , pub (crate) dep_type : Byte , } impl CellDepBuilder { pub const TOTAL_SIZE : usize = 37 ; pub const FIELD_SIZES : [usize ; 2] = [36 , 1 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn out_point < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < OutPoint > { self . out_point = v . into () ; self } pub fn dep_type < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . dep_type = v . into () ; self } } impl molecule :: prelude :: Builder for CellDepBuilder { type Entity = CellDep ; const NAME : & 'static str = "CellDepBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . out_point . as_slice ()) ? ; writer . write_all (self . dep_type . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellDep :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct RawTransaction (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for RawTransaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for RawTransaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for RawTransaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "cell_deps" , self . cell_deps ()) ? ; write ! (f , ", {}: {}" , "header_deps" , self . header_deps ()) ? ; write ! (f , ", {}: {}" , "inputs" , self . inputs ()) ? ; write ! (f , ", {}: {}" , "outputs" , self . outputs ()) ? ; write ! (f , ", {}: {}" , "outputs_data" , self . outputs_data ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for RawTransaction { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; RawTransaction :: new_unchecked (v) } } impl RawTransaction { const DEFAULT_VALUE : [u8 ; 52] = [52 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn version (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn cell_deps (& self) -> CellDepVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; CellDepVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn header_deps (& self) -> Byte32Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte32Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn inputs (& self) -> CellInputVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; CellInputVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn outputs (& self) -> CellOutputVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; CellOutputVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn outputs_data (& self) -> BytesVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; BytesVec :: new_unchecked (self . 0 . slice (start .. end)) } else { BytesVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> RawTransactionReader < 'r > { RawTransactionReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for RawTransaction { type Builder = RawTransactionBuilder ; const NAME : & 'static str = "RawTransaction" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { RawTransaction (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { RawTransactionReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { RawTransactionReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . version (self . version ()) . cell_deps (self . cell_deps ()) . header_deps (self . header_deps ()) . inputs (self . inputs ()) . outputs (self . outputs ()) . outputs_data (self . outputs_data ()) } }
# [derive (Clone , Copy)] pub struct RawTransactionReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for RawTransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for RawTransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for RawTransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "cell_deps" , self . cell_deps ()) ? ; write ! (f , ", {}: {}" , "header_deps" , self . header_deps ()) ? ; write ! (f , ", {}: {}" , "inputs" , self . inputs ()) ? ; write ! (f , ", {}: {}" , "outputs" , self . outputs ()) ? ; write ! (f , ", {}: {}" , "outputs_data" , self . outputs_data ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > RawTransactionReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn version (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn cell_deps (& self) -> CellDepVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; CellDepVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn header_deps (& self) -> Byte32VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte32VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn inputs (& self) -> CellInputVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; CellInputVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn outputs (& self) -> CellOutputVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; CellOutputVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn outputs_data (& self) -> BytesVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; BytesVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for RawTransactionReader < 'r > { type Entity = RawTransaction ; const NAME : & 'static str = "RawTransactionReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { RawTransactionReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; CellDepVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Byte32VecReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; CellInputVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; CellOutputVecReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; BytesVecReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct RawTransactionBuilder { pub (crate) version : Uint32 , pub (crate) cell_deps : CellDepVec , pub (crate) header_deps : Byte32Vec , pub (crate) inputs : CellInputVec , pub (crate) outputs : CellOutputVec , pub (crate) outputs_data : BytesVec , } impl RawTransactionBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn version < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . version = v . into () ; self } pub fn cell_deps < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellDepVec > { self . cell_deps = v . into () ; self } pub fn header_deps < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Vec > { self . header_deps = v . into () ; self } pub fn inputs < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellInputVec > { self . inputs = v . into () ; self } pub fn outputs < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CellOutputVec > { self . outputs = v . into () ; self } pub fn outputs_data < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesVec > { self . outputs_data = v . into () ; self } } impl molecule :: prelude :: Builder for RawTransactionBuilder { type Entity = RawTransaction ; const NAME : & 'static str = "RawTransactionBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . version . as_slice () . len () + self . cell_deps . as_slice () . len () + self . header_deps . as_slice () . len () + self . inputs . as_slice () . len () + self . outputs . as_slice () . len () + self . outputs_data . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . version . as_slice () . len () ; offsets . push (total_size) ; total_size += self . cell_deps . as_slice () . len () ; offsets . push (total_size) ; total_size += self . header_deps . as_slice () . len () ; offsets . push (total_size) ; total_size += self . inputs . as_slice () . len () ; offsets . push (total_size) ; total_size += self . outputs . as_slice () . len () ; offsets . push (total_size) ; total_size += self . outputs_data . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . version . as_slice ()) ? ; writer . write_all (self . cell_deps . as_slice ()) ? ; writer . write_all (self . header_deps . as_slice ()) ? ; writer . write_all (self . inputs . as_slice ()) ? ; writer . write_all (self . outputs . as_slice ()) ? ; writer . write_all (self . outputs_data . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; RawTransaction :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Transaction (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Transaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Transaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Transaction { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "raw" , self . raw ()) ? ; write ! (f , ", {}: {}" , "witnesses" , self . witnesses ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Transaction { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Transaction :: new_unchecked (v) } } impl Transaction { const DEFAULT_VALUE : [u8 ; 68] = [68 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 52 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn raw (& self) -> RawTransaction { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; RawTransaction :: new_unchecked (self . 0 . slice (start .. end)) } pub fn witnesses (& self) -> BytesVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesVec :: new_unchecked (self . 0 . slice (start .. end)) } else { BytesVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> TransactionReader < 'r > { TransactionReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Transaction { type Builder = TransactionBuilder ; const NAME : & 'static str = "Transaction" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Transaction (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TransactionReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TransactionReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . raw (self . raw ()) . witnesses (self . witnesses ()) } }
# [derive (Clone , Copy)] pub struct TransactionReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TransactionReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "raw" , self . raw ()) ? ; write ! (f , ", {}: {}" , "witnesses" , self . witnesses ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > TransactionReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn raw (& self) -> RawTransactionReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; RawTransactionReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn witnesses (& self) -> BytesVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TransactionReader < 'r > { type Entity = Transaction ; const NAME : & 'static str = "TransactionReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TransactionReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } RawTransactionReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TransactionBuilder { pub (crate) raw : RawTransaction , pub (crate) witnesses : BytesVec , } impl TransactionBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn raw < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < RawTransaction > { self . raw = v . into () ; self } pub fn witnesses < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesVec > { self . witnesses = v . into () ; self } } impl molecule :: prelude :: Builder for TransactionBuilder { type Entity = Transaction ; const NAME : & 'static str = "TransactionBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . raw . as_slice () . len () + self . witnesses . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . raw . as_slice () . len () ; offsets . push (total_size) ; total_size += self . witnesses . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . raw . as_slice ()) ? ; writer . write_all (self . witnesses . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Transaction :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct RawHeader (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for RawHeader { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for RawHeader { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for RawHeader { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "compact_target" , self . compact_target ()) ? ; write ! (f , ", {}: {}" , "timestamp" , self . timestamp ()) ? ; write ! (f , ", {}: {}" , "number" , self . number ()) ? ; write ! (f , ", {}: {}" , "epoch" , self . epoch ()) ? ; write ! (f , ", {}: {}" , "parent_hash" , self . parent_hash ()) ? ; write ! (f , ", {}: {}" , "transactions_root" , self . transactions_root ()) ? ; write ! (f , ", {}: {}" , "proposals_hash" , self . proposals_hash ()) ? ; write ! (f , ", {}: {}" , "extra_hash" , self . extra_hash ()) ? ; write ! (f , ", {}: {}" , "dao" , self . dao ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for RawHeader { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; RawHeader :: new_unchecked (v) } } impl RawHeader { const DEFAULT_VALUE : [u8 ; 192] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 192 ; pub const FIELD_SIZES : [usize ; 10] = [4 , 4 , 8 , 8 , 8 , 32 , 32 , 32 , 32 , 32 ,] ; pub const FIELD_COUNT : usize = 10 ; pub fn version (& self) -> Uint32 { Uint32 :: new_unchecked (self . 0 . slice (0 .. 4)) } pub fn compact_target (& self) -> Uint32 { Uint32 :: new_unchecked (self . 0 . slice (4 .. 8)) } pub fn timestamp (& self) -> Uint64 { Uint64 :: new_unchecked (self . 0 . slice (8 .. 16)) } pub fn number (& self) -> Uint64 { Uint64 :: new_unchecked (self . 0 . slice (16 .. 24)) } pub fn epoch (& self) -> Uint64 { Uint64 :: new_unchecked (self . 0 . slice (24 .. 32)) } pub fn parent_hash (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (32 .. 64)) } pub fn transactions_root (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (64 .. 96)) } pub fn proposals_hash (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (96 .. 128)) } pub fn extra_hash (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (128 .. 160)) } pub fn dao (& self) -> Byte32 { Byte32 :: new_unchecked (self . 0 . slice (160 .. 192)) } pub fn as_reader < 'r > (& 'r self) -> RawHeaderReader < 'r > { RawHeaderReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for RawHeader { type Builder = RawHeaderBuilder ; const NAME : & 'static str = "RawHeader" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { RawHeader (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { RawHeaderReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { RawHeaderReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . version (self . version ()) . compact_target (self . compact_target ()) . timestamp (self . timestamp ()) . number (self . number ()) . epoch (self . epoch ()) . parent_hash (self . parent_hash ()) . transactions_root (self . transactions_root ()) . proposals_hash (self . proposals_hash ()) . extra_hash (self . extra_hash ()) . dao (self . dao ()) } }
# [derive (Clone , Copy)] pub struct RawHeaderReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for RawHeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for RawHeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for RawHeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "compact_target" , self . compact_target ()) ? ; write ! (f , ", {}: {}" , "timestamp" , self . timestamp ()) ? ; write ! (f , ", {}: {}" , "number" , self . number ()) ? ; write ! (f , ", {}: {}" , "epoch" , self . epoch ()) ? ; write ! (f , ", {}: {}" , "parent_hash" , self . parent_hash ()) ? ; write ! (f , ", {}: {}" , "transactions_root" , self . transactions_root ()) ? ; write ! (f , ", {}: {}" , "proposals_hash" , self . proposals_hash ()) ? ; write ! (f , ", {}: {}" , "extra_hash" , self . extra_hash ()) ? ; write ! (f , ", {}: {}" , "dao" , self . dao ()) ? ; write ! (f , " }}") } } impl < 'r > RawHeaderReader < 'r > { pub const TOTAL_SIZE : usize = 192 ; pub const FIELD_SIZES : [usize ; 10] = [4 , 4 , 8 , 8 , 8 , 32 , 32 , 32 , 32 , 32 ,] ; pub const FIELD_COUNT : usize = 10 ; pub fn version (& self) -> Uint32Reader < 'r > { Uint32Reader :: new_unchecked (& self . as_slice () [0 .. 4]) } pub fn compact_target (& self) -> Uint32Reader < 'r > { Uint32Reader :: new_unchecked (& self . as_slice () [4 .. 8]) } pub fn timestamp (& self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (& self . as_slice () [8 .. 16]) } pub fn number (& self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (& self . as_slice () [16 .. 24]) } pub fn epoch (& self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (& self . as_slice () [24 .. 32]) } pub fn parent_hash (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [32 .. 64]) } pub fn transactions_root (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [64 .. 96]) } pub fn proposals_hash (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [96 .. 128]) } pub fn extra_hash (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [128 .. 160]) } pub fn dao (& self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (& self . as_slice () [160 .. 192]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for RawHeaderReader < 'r > { type Entity = RawHeader ; const NAME : & 'static str = "RawHeaderReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { RawHeaderReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct RawHeaderBuilder { pub (crate) version : Uint32 , pub (crate) compact_target : Uint32 , pub (crate) timestamp : Uint64 , pub (crate) number : Uint64 , pub (crate) epoch : Uint64 , pub (crate) parent_hash : Byte32 , pub (crate) transactions_root : Byte32 , pub (crate) proposals_hash : Byte32 , pub (crate) extra_hash : Byte32 , pub (crate) dao : Byte32 , } impl RawHeaderBuilder { pub const TOTAL_SIZE : usize = 192 ; pub const FIELD_SIZES : [usize ; 10] = [4 , 4 , 8 , 8 , 8 , 32 , 32 , 32 , 32 , 32 ,] ; pub const FIELD_COUNT : usize = 10 ; pub fn version < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . version = v . into () ; self } pub fn compact_target < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . compact_target = v . into () ; self } pub fn timestamp < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . timestamp = v . into () ; self } pub fn number < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . number = v . into () ; self } pub fn epoch < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . epoch = v . into () ; self } pub fn parent_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . parent_hash = v . into () ; self } pub fn transactions_root < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . transactions_root = v . into () ; self } pub fn proposals_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . proposals_hash = v . into () ; self } pub fn extra_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . extra_hash = v . into () ; self } pub fn dao < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . dao = v . into () ; self } } impl molecule :: prelude :: Builder for RawHeaderBuilder { type Entity = RawHeader ; const NAME : & 'static str = "RawHeaderBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . version . as_slice ()) ? ; writer . write_all (self . compact_target . as_slice ()) ? ; writer . write_all (self . timestamp . as_slice ()) ? ; writer . write_all (self . number . as_slice ()) ? ; writer . write_all (self . epoch . as_slice ()) ? ; writer . write_all (self . parent_hash . as_slice ()) ? ; writer . write_all (self . transactions_root . as_slice ()) ? ; writer . write_all (self . proposals_hash . as_slice ()) ? ; writer . write_all (self . extra_hash . as_slice ()) ? ; writer . write_all (self . dao . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; RawHeader :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Header (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Header { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Header { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Header { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "raw" , self . raw ()) ? ; write ! (f , ", {}: {}" , "nonce" , self . nonce ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for Header { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Header :: new_unchecked (v) } } impl Header { const DEFAULT_VALUE : [u8 ; 208] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 208 ; pub const FIELD_SIZES : [usize ; 2] = [192 , 16 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn raw (& self) -> RawHeader { RawHeader :: new_unchecked (self . 0 . slice (0 .. 192)) } pub fn nonce (& self) -> Uint128 { Uint128 :: new_unchecked (self . 0 . slice (192 .. 208)) } pub fn as_reader < 'r > (& 'r self) -> HeaderReader < 'r > { HeaderReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Header { type Builder = HeaderBuilder ; const NAME : & 'static str = "Header" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Header (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { HeaderReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { HeaderReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . raw (self . raw ()) . nonce (self . nonce ()) } }
# [derive (Clone , Copy)] pub struct HeaderReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for HeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for HeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for HeaderReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "raw" , self . raw ()) ? ; write ! (f , ", {}: {}" , "nonce" , self . nonce ()) ? ; write ! (f , " }}") } } impl < 'r > HeaderReader < 'r > { pub const TOTAL_SIZE : usize = 208 ; pub const FIELD_SIZES : [usize ; 2] = [192 , 16 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn raw (& self) -> RawHeaderReader < 'r > { RawHeaderReader :: new_unchecked (& self . as_slice () [0 .. 192]) } pub fn nonce (& self) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked (& self . as_slice () [192 .. 208]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for HeaderReader < 'r > { type Entity = Header ; const NAME : & 'static str = "HeaderReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { HeaderReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct HeaderBuilder { pub (crate) raw : RawHeader , pub (crate) nonce : Uint128 , } impl HeaderBuilder { pub const TOTAL_SIZE : usize = 208 ; pub const FIELD_SIZES : [usize ; 2] = [192 , 16 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn raw < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < RawHeader > { self . raw = v . into () ; self } pub fn nonce < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint128 > { self . nonce = v . into () ; self } } impl molecule :: prelude :: Builder for HeaderBuilder { type Entity = Header ; const NAME : & 'static str = "HeaderBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . raw . as_slice ()) ? ; writer . write_all (self . nonce . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Header :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct UncleBlock (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UncleBlock { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UncleBlock { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UncleBlock { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for UncleBlock { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UncleBlock :: new_unchecked (v) } } impl UncleBlock { const DEFAULT_VALUE : [u8 ; 224] = [224 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 220 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> Header { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Header :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proposals (& self) -> ProposalShortIdVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ProposalShortIdVec :: new_unchecked (self . 0 . slice (start .. end)) } else { ProposalShortIdVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> UncleBlockReader < 'r > { UncleBlockReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UncleBlock { type Builder = UncleBlockBuilder ; const NAME : & 'static str = "UncleBlock" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UncleBlock (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UncleBlockReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UncleBlockReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . header (self . header ()) . proposals (self . proposals ()) } }
# [derive (Clone , Copy)] pub struct UncleBlockReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UncleBlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UncleBlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UncleBlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > UncleBlockReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> HeaderReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; HeaderReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proposals (& self) -> ProposalShortIdVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ProposalShortIdVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ProposalShortIdVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UncleBlockReader < 'r > { type Entity = UncleBlock ; const NAME : & 'static str = "UncleBlockReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UncleBlockReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } HeaderReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; ProposalShortIdVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UncleBlockBuilder { pub (crate) header : Header , pub (crate) proposals : ProposalShortIdVec , } impl UncleBlockBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn header < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Header > { self . header = v . into () ; self } pub fn proposals < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ProposalShortIdVec > { self . proposals = v . into () ; self } } impl molecule :: prelude :: Builder for UncleBlockBuilder { type Entity = UncleBlock ; const NAME : & 'static str = "UncleBlockBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . header . as_slice () . len () + self . proposals . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . header . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proposals . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . header . as_slice ()) ? ; writer . write_all (self . proposals . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UncleBlock :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Block (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Block { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Block { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Block { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "uncles" , self . uncles ()) ? ; write ! (f , ", {}: {}" , "transactions" , self . transactions ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Block { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Block :: new_unchecked (v) } } impl Block { const DEFAULT_VALUE : [u8 ; 240] = [240 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 228 , 0 , 0 , 0 , 232 , 0 , 0 , 0 , 236 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> Header { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Header :: new_unchecked (self . 0 . slice (start .. end)) } pub fn uncles (& self) -> UncleBlockVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; UncleBlockVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn transactions (& self) -> TransactionVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TransactionVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proposals (& self) -> ProposalShortIdVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ProposalShortIdVec :: new_unchecked (self . 0 . slice (start .. end)) } else { ProposalShortIdVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> BlockReader < 'r > { BlockReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Block { type Builder = BlockBuilder ; const NAME : & 'static str = "Block" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Block (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BlockReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BlockReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . header (self . header ()) . uncles (self . uncles ()) . transactions (self . transactions ()) . proposals (self . proposals ()) } }
# [derive (Clone , Copy)] pub struct BlockReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BlockReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "uncles" , self . uncles ()) ? ; write ! (f , ", {}: {}" , "transactions" , self . transactions ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > BlockReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> HeaderReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; HeaderReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn uncles (& self) -> UncleBlockVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; UncleBlockVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn transactions (& self) -> TransactionVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TransactionVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proposals (& self) -> ProposalShortIdVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ProposalShortIdVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ProposalShortIdVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BlockReader < 'r > { type Entity = Block ; const NAME : & 'static str = "BlockReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BlockReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } HeaderReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; UncleBlockVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; TransactionVecReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; ProposalShortIdVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BlockBuilder { pub (crate) header : Header , pub (crate) uncles : UncleBlockVec , pub (crate) transactions : TransactionVec , pub (crate) proposals : ProposalShortIdVec , } impl BlockBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn header < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Header > { self . header = v . into () ; self } pub fn uncles < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UncleBlockVec > { self . uncles = v . into () ; self } pub fn transactions < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TransactionVec > { self . transactions = v . into () ; self } pub fn proposals < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ProposalShortIdVec > { self . proposals = v . into () ; self } } impl molecule :: prelude :: Builder for BlockBuilder { type Entity = Block ; const NAME : & 'static str = "BlockBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . header . as_slice () . len () + self . uncles . as_slice () . len () + self . transactions . as_slice () . len () + self . proposals . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . header . as_slice () . len () ; offsets . push (total_size) ; total_size += self . uncles . as_slice () . len () ; offsets . push (total_size) ; total_size += self . transactions . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proposals . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . header . as_slice ()) ? ; writer . write_all (self . uncles . as_slice ()) ? ; writer . write_all (self . transactions . as_slice ()) ? ; writer . write_all (self . proposals . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Block :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct BlockV1 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BlockV1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BlockV1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BlockV1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "uncles" , self . uncles ()) ? ; write ! (f , ", {}: {}" , "transactions" , self . transactions ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; write ! (f , ", {}: {}" , "extension" , self . extension ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for BlockV1 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BlockV1 :: new_unchecked (v) } } impl BlockV1 { const DEFAULT_VALUE : [u8 ; 248] = [248 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 232 , 0 , 0 , 0 , 236 , 0 , 0 , 0 , 240 , 0 , 0 , 0 , 244 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 5 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> Header { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Header :: new_unchecked (self . 0 . slice (start .. end)) } pub fn uncles (& self) -> UncleBlockVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; UncleBlockVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn transactions (& self) -> TransactionVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TransactionVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proposals (& self) -> ProposalShortIdVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ProposalShortIdVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn extension (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> BlockV1Reader < 'r > { BlockV1Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BlockV1 { type Builder = BlockV1Builder ; const NAME : & 'static str = "BlockV1" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BlockV1 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BlockV1Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BlockV1Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . header (self . header ()) . uncles (self . uncles ()) . transactions (self . transactions ()) . proposals (self . proposals ()) . extension (self . extension ()) } }
# [derive (Clone , Copy)] pub struct BlockV1Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BlockV1Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BlockV1Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BlockV1Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "header" , self . header ()) ? ; write ! (f , ", {}: {}" , "uncles" , self . uncles ()) ? ; write ! (f , ", {}: {}" , "transactions" , self . transactions ()) ? ; write ! (f , ", {}: {}" , "proposals" , self . proposals ()) ? ; write ! (f , ", {}: {}" , "extension" , self . extension ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > BlockV1Reader < 'r > { pub const FIELD_COUNT : usize = 5 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn header (& self) -> HeaderReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; HeaderReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn uncles (& self) -> UncleBlockVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; UncleBlockVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn transactions (& self) -> TransactionVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TransactionVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proposals (& self) -> ProposalShortIdVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ProposalShortIdVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn extension (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [24 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BlockV1Reader < 'r > { type Entity = BlockV1 ; const NAME : & 'static str = "BlockV1Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BlockV1Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } HeaderReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; UncleBlockVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; TransactionVecReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; ProposalShortIdVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; BytesReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BlockV1Builder { pub (crate) header : Header , pub (crate) uncles : UncleBlockVec , pub (crate) transactions : TransactionVec , pub (crate) proposals : ProposalShortIdVec , pub (crate) extension : Bytes , } impl BlockV1Builder { pub const FIELD_COUNT : usize = 5 ; pub fn header < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Header > { self . header = v . into () ; self } pub fn uncles < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UncleBlockVec > { self . uncles = v . into () ; self } pub fn transactions < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TransactionVec > { self . transactions = v . into () ; self } pub fn proposals < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ProposalShortIdVec > { self . proposals = v . into () ; self } pub fn extension < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Bytes > { self . extension = v . into () ; self } } impl molecule :: prelude :: Builder for BlockV1Builder { type Entity = BlockV1 ; const NAME : & 'static str = "BlockV1Builder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . header . as_slice () . len () + self . uncles . as_slice () . len () + self . transactions . as_slice () . len () + self . proposals . as_slice () . len () + self . extension . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . header . as_slice () . len () ; offsets . push (total_size) ; total_size += self . uncles . as_slice () . len () ; offsets . push (total_size) ; total_size += self . transactions . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proposals . as_slice () . len () ; offsets . push (total_size) ; total_size += self . extension . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . header . as_slice ()) ? ; writer . write_all (self . uncles . as_slice ()) ? ; writer . write_all (self . transactions . as_slice ()) ? ; writer . write_all (self . proposals . as_slice ()) ? ; writer . write_all (self . extension . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BlockV1 :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CellbaseWitness (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CellbaseWitness { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CellbaseWitness { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CellbaseWitness { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "message" , self . message ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for CellbaseWitness { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CellbaseWitness :: new_unchecked (v) } } impl CellbaseWitness { const DEFAULT_VALUE : [u8 ; 69] = [69 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 65 , 0 , 0 , 0 , 53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn lock (& self) -> Script { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Script :: new_unchecked (self . 0 . slice (start .. end)) } pub fn message (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> CellbaseWitnessReader < 'r > { CellbaseWitnessReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CellbaseWitness { type Builder = CellbaseWitnessBuilder ; const NAME : & 'static str = "CellbaseWitness" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CellbaseWitness (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellbaseWitnessReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CellbaseWitnessReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . lock (self . lock ()) . message (self . message ()) } }
# [derive (Clone , Copy)] pub struct CellbaseWitnessReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CellbaseWitnessReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CellbaseWitnessReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CellbaseWitnessReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "message" , self . message ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > CellbaseWitnessReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn lock (& self) -> ScriptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; ScriptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn message (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellbaseWitnessReader < 'r > { type Entity = CellbaseWitness ; const NAME : & 'static str = "CellbaseWitnessReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CellbaseWitnessReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } ScriptReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CellbaseWitnessBuilder { pub (crate) lock : Script , pub (crate) message : Bytes , } impl CellbaseWitnessBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn lock < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Script > { self . lock = v . into () ; self } pub fn message < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Bytes > { self . message = v . into () ; self } } impl molecule :: prelude :: Builder for CellbaseWitnessBuilder { type Entity = CellbaseWitness ; const NAME : & 'static str = "CellbaseWitnessBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . lock . as_slice () . len () + self . message . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . lock . as_slice () . len () ; offsets . push (total_size) ; total_size += self . message . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . lock . as_slice ()) ? ; writer . write_all (self . message . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CellbaseWitness :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct WitnessArgs (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for WitnessArgs { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for WitnessArgs { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for WitnessArgs { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "input_type" , self . input_type ()) ? ; write ! (f , ", {}: {}" , "output_type" , self . output_type ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for WitnessArgs { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; WitnessArgs :: new_unchecked (v) } } impl WitnessArgs { const DEFAULT_VALUE : [u8 ; 16] = [16 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 16 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn lock (& self) -> BytesOpt { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; BytesOpt :: new_unchecked (self . 0 . slice (start .. end)) } pub fn input_type (& self) -> BytesOpt { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesOpt :: new_unchecked (self . 0 . slice (start .. end)) } pub fn output_type (& self) -> BytesOpt { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; BytesOpt :: new_unchecked (self . 0 . slice (start .. end)) } else { BytesOpt :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> WitnessArgsReader < 'r > { WitnessArgsReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for WitnessArgs { type Builder = WitnessArgsBuilder ; const NAME : & 'static str = "WitnessArgs" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { WitnessArgs (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { WitnessArgsReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { WitnessArgsReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . lock (self . lock ()) . input_type (self . input_type ()) . output_type (self . output_type ()) } }
# [derive (Clone , Copy)] pub struct WitnessArgsReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for WitnessArgsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for WitnessArgsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for WitnessArgsReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "lock" , self . lock ()) ? ; write ! (f , ", {}: {}" , "input_type" , self . input_type ()) ? ; write ! (f , ", {}: {}" , "output_type" , self . output_type ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > WitnessArgsReader < 'r > { pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn lock (& self) -> BytesOptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; BytesOptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn input_type (& self) -> BytesOptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesOptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn output_type (& self) -> BytesOptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; BytesOptReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesOptReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for WitnessArgsReader < 'r > { type Entity = WitnessArgs ; const NAME : & 'static str = "WitnessArgsReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { WitnessArgsReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } BytesOptReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesOptReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; BytesOptReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct WitnessArgsBuilder { pub (crate) lock : BytesOpt , pub (crate) input_type : BytesOpt , pub (crate) output_type : BytesOpt , } impl WitnessArgsBuilder { pub const FIELD_COUNT : usize = 3 ; pub fn lock < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesOpt > { self . lock = v . into () ; self } pub fn input_type < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesOpt > { self . input_type = v . into () ; self } pub fn output_type < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < BytesOpt > { self . output_type = v . into () ; self } } impl molecule :: prelude :: Builder for WitnessArgsBuilder { type Entity = WitnessArgs ; const NAME : & 'static str = "WitnessArgsBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . lock . as_slice () . len () + self . input_type . as_slice () . len () + self . output_type . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . lock . as_slice () . len () ; offsets . push (total_size) ; total_size += self . input_type . as_slice () . len () ; offsets . push (total_size) ; total_size += self . output_type . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . lock . as_slice ()) ? ; writer . write_all (self . input_type . as_slice ()) ? ; writer . write_all (self . output_type . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; WitnessArgs :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Byte32Opt (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32Opt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32Opt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32Opt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl :: core :: default :: Default for Byte32Opt { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32Opt :: new_unchecked (v) } } impl Byte32Opt { const DEFAULT_VALUE : [u8 ; 0] = [] ; pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < Byte32 > { if self . is_none () { None } else { Some (Byte32 :: new_unchecked (self . 0 . clone ())) } } pub fn as_reader < 'r > (& 'r self) -> Byte32OptReader < 'r > { Byte32OptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32Opt { type Builder = Byte32OptBuilder ; const NAME : & 'static str = "Byte32Opt" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32Opt (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32OptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32OptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set (self . to_opt ()) } }
# [derive (Clone , Copy)] pub struct Byte32OptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32OptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32OptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32OptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl < 'r > Byte32OptReader < 'r > { pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < Byte32Reader < 'r > > { if self . is_none () { None } else { Some (Byte32Reader :: new_unchecked (self . as_slice ())) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32OptReader < 'r > { type Entity = Byte32Opt ; const NAME : & 'static str = "Byte32OptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32OptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { if ! slice . is_empty () { Byte32Reader :: verify (& slice [..] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Byte32OptBuilder (pub (crate) Option < Byte32 >) ; impl Byte32OptBuilder { pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Option < Byte32 >> { self . 0 = v . into () ; self } } impl molecule :: prelude :: Builder for Byte32OptBuilder { type Entity = Byte32Opt ; const NAME : & 'static str = "Byte32OptBuilder" ; fn expected_length (& self) -> usize { self . 0 . as_ref () . map (| ref inner | inner . as_slice () . len ()) . unwrap_or (0) } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { self . 0 . as_ref () . map (| ref inner | writer . write_all (inner . as_slice ())) . unwrap_or (Ok (())) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32Opt :: new_unchecked (inner . into ()) } }
impl From < Byte32 > for Byte32Opt { fn from (value : Byte32) -> Self { Self :: new_builder () . set (Some (value)) . build () } }
# [derive (Clone)] pub struct ScriptVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for ScriptVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ScriptVec :: new_unchecked (v) } } impl ScriptVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Script > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Script { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Script :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Script :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> ScriptVecReader < 'r > { ScriptVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ScriptVec { type Builder = ScriptVecBuilder ; const NAME : & 'static str = "ScriptVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ScriptVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct ScriptVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > ScriptVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ScriptReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ScriptReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { ScriptReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; ScriptReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptVecReader < 'r > { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; ScriptReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptVecBuilder (pub (crate) Vec < Script >) ; impl ScriptVecBuilder { pub fn set (mut self , v : Vec < Script >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Script > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Script >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Script > where T : :: core :: convert :: Into < Script > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for ScriptVecBuilder { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ScriptVec :: new_unchecked (inner . into ()) } }
pub struct ScriptVecIterator (ScriptVec , usize , usize) ; impl :: core :: iter :: Iterator for ScriptVecIterator { type Item = Script ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for ScriptVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ScriptVec { type Item = Script ; type IntoIter = ScriptVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; ScriptVecIterator (self , 0 , len) } } impl < 'r > ScriptVecReader < 'r > { pub fn iter < 't > (& 't self) -> ScriptVecReaderIterator < 't , 'r > { ScriptVecReaderIterator (& self , 0 , self . len ()) } } pub struct ScriptVecReaderIterator < 't , 'r > (& 't ScriptVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ScriptVecReaderIterator < 't , 'r > { type Item = ScriptReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ScriptVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Script > for ScriptVec { fn from_iter < T : IntoIterator < Item = Script >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Script >> for ScriptVec { fn from (v : Vec < Script >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct Uint128Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint128Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint128Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint128Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Uint128Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint128Vec :: new_unchecked (v) } } impl Uint128Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 16 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint128 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint128 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint128 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Uint128VecReader < 'r > { Uint128VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint128Vec { type Builder = Uint128VecBuilder ; const NAME : & 'static str = "Uint128Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint128Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Uint128VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint128VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint128VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint128VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Uint128VecReader < 'r > { pub const ITEM_SIZE : usize = 16 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint128Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint128Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint128Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint128VecReader < 'r > { type Entity = Uint128Vec ; const NAME : & 'static str = "Uint128VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint128VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Uint128VecBuilder (pub (crate) Vec < Uint128 >) ; impl Uint128VecBuilder { pub const ITEM_SIZE : usize = 16 ; pub fn set (mut self , v : Vec < Uint128 >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint128 > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Uint128 >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Uint128 > where T : :: core :: convert :: Into < Uint128 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for Uint128VecBuilder { type Entity = Uint128Vec ; const NAME : & 'static str = "Uint128VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint128Vec :: new_unchecked (inner . into ()) } }
pub struct Uint128VecIterator (Uint128Vec , usize , usize) ; impl :: core :: iter :: Iterator for Uint128VecIterator { type Item = Uint128 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Uint128VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Uint128Vec { type Item = Uint128 ; type IntoIter = Uint128VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Uint128VecIterator (self , 0 , len) } } impl < 'r > Uint128VecReader < 'r > { pub fn iter < 't > (& 't self) -> Uint128VecReaderIterator < 't , 'r > { Uint128VecReaderIterator (& self , 0 , self . len ()) } } pub struct Uint128VecReaderIterator < 't , 'r > (& 't Uint128VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Uint128VecReaderIterator < 't , 'r > { type Item = Uint128Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Uint128VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Uint128 > for Uint128Vec { fn from_iter < T : IntoIterator < Item = Uint128 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Uint128 >> for Uint128Vec { fn from (v : Vec < Uint128 >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct Uint8 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint8 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint8 :: new_unchecked (v) } } impl Uint8 { const DEFAULT_VALUE : [u8 ; 1] = [0 ,] ; pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint8Reader < 'r > { Uint8Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint8 { type Builder = Uint8Builder ; const NAME : & 'static str = "Uint8" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint8 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint8Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint8Reader < 'r > { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint8Reader < 'r > { type Entity = Uint8 ; const NAME : & 'static str = "Uint8Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint8Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint8Builder (pub (crate) [Byte ; 1]) ; impl :: core :: fmt :: Debug for Uint8Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint8Builder { fn default () -> Self { Uint8Builder ([Byte :: default () ,]) } } impl Uint8Builder { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn set < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < [Byte ; 1] > { self . 0 = v . into () ; self } pub fn nth0 < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 [0] = v . into () ; self } } impl molecule :: prelude :: Builder for Uint8Builder { type Entity = Uint8 ; const NAME : & 'static str = "Uint8Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint8 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 1usize] > for Uint8 { fn from (value : [Byte ; 1usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint8 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 1usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint8 > for [Byte ; 1usize] { # [track_caller] fn from (value : Uint8) -> Self { [value . nth0 () ,] } } impl From < [u8 ; 1usize] > for Uint8 { fn from (value : [u8 ; 1usize]) -> Self { Uint8Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint8 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 1usize] > :: try_from (value) ? . into ()) } } impl From < Uint8 > for [u8 ; 1usize] { # [track_caller] fn from (value : Uint8) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint8Reader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : Uint8Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint8Reader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : & 'a Uint8Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint8Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Uint8Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint8Vec :: new_unchecked (v) } } impl Uint8Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint8 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint8 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Uint8VecReader < 'r > { Uint8VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint8Vec { type Builder = Uint8VecBuilder ; const NAME : & 'static str = "Uint8Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint8Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Uint8VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Uint8VecReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint8Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint8Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint8VecReader < 'r > { type Entity = Uint8Vec ; const NAME : & 'static str = "Uint8VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint8VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Uint8VecBuilder (pub (crate) Vec < Uint8 >) ; impl Uint8VecBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Uint8 >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8 > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Uint8 >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Uint8 > where T : :: core :: convert :: Into < Uint8 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for Uint8VecBuilder { type Entity = Uint8Vec ; const NAME : & 'static str = "Uint8VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint8Vec :: new_unchecked (inner . into ()) } }
pub struct Uint8VecIterator (Uint8Vec , usize , usize) ; impl :: core :: iter :: Iterator for Uint8VecIterator { type Item = Uint8 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Uint8VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Uint8Vec { type Item = Uint8 ; type IntoIter = Uint8VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Uint8VecIterator (self , 0 , len) } } impl < 'r > Uint8VecReader < 'r > { pub fn iter < 't > (& 't self) -> Uint8VecReaderIterator < 't , 'r > { Uint8VecReaderIterator (& self , 0 , self . len ()) } } pub struct Uint8VecReaderIterator < 't , 'r > (& 't Uint8VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Uint8VecReaderIterator < 't , 'r > { type Item = Uint8Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Uint8VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Uint8 > for Uint8Vec { fn from_iter < T : IntoIterator < Item = Uint8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Uint8 >> for Uint8Vec { fn from (v : Vec < Uint8 >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct String (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for String { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; String :: new_unchecked (v) } } impl String { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> StringReader < 'r > { StringReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for String { type Builder = StringBuilder ; const NAME : & 'static str = "String" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { String (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { StringReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { StringReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct StringReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > StringReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for StringReader < 'r > { type Entity = String ; const NAME : & 'static str = "StringReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { StringReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct StringBuilder (pub (crate) Vec < Byte >) ; impl StringBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < Byte > where T : :: core :: convert :: Into < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for StringBuilder { type Entity = String ; const NAME : & 'static str = "StringBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; String :: new_unchecked (inner . into ()) } }
pub struct StringIterator (String , usize , usize) ; impl :: core :: iter :: Iterator for StringIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for StringIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for String { type Item = Byte ; type IntoIter = StringIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; StringIterator (self , 0 , len) } }
impl :: core :: iter :: FromIterator < Byte > for String { fn from_iter < T : IntoIterator < Item = Byte >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < Byte >> for String { fn from (v : Vec < Byte >) -> Self { Self :: new_builder () . set (v) . build () } } impl :: core :: iter :: FromIterator < u8 > for String { fn from_iter < T : IntoIterator < Item = u8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter . into_iter () . map (Into :: into)) . build () } } impl From < Vec < u8 >> for String { fn from (v : Vec < u8 >) -> Self { Self :: new_builder () . set (v . into_iter () . map (Into :: into) . collect ()) . build () } }
# [derive (Clone)] pub struct StringVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for StringVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; StringVec :: new_unchecked (v) } } impl StringVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < String > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> String { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { String :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> StringVecReader < 'r > { StringVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for StringVec { type Builder = StringVecBuilder ; const NAME : & 'static str = "StringVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { StringVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { StringVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { StringVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct StringVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > StringVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < StringReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> StringReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { StringReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for StringVecReader < 'r > { type Entity = StringVec ; const NAME : & 'static str = "StringVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { StringVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; StringReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct StringVecBuilder (pub (crate) Vec < String >) ; impl StringVecBuilder { pub fn set (mut self , v : Vec < String >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = String >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < String > where T : :: core :: convert :: Into < String > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for StringVecBuilder { type Entity = StringVec ; const NAME : & 'static str = "StringVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; StringVec :: new_unchecked (inner . into ()) } }
pub struct StringVecIterator (StringVec , usize , usize) ; impl :: core :: iter :: Iterator for StringVecIterator { type Item = String ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for StringVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for StringVec { type Item = String ; type IntoIter = StringVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; StringVecIterator (self , 0 , len) } } impl < 'r > StringVecReader < 'r > { pub fn iter < 't > (& 't self) -> StringVecReaderIterator < 't , 'r > { StringVecReaderIterator (& self , 0 , self . len ()) } } pub struct StringVecReaderIterator < 't , 'r > (& 't StringVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for StringVecReaderIterator < 't , 'r > { type Item = StringReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for StringVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < String > for StringVec { fn from_iter < T : IntoIterator < Item = String >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < String >> for StringVec { fn from (v : Vec < String >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct UDTAsset (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UDTAsset { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UDTAsset { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UDTAsset { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "udt_script" , self . udt_script ()) ? ; write ! (f , ", {}: {}" , "amount" , self . amount ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for UDTAsset { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UDTAsset :: new_unchecked (v) } } impl UDTAsset { const DEFAULT_VALUE : [u8 ; 81] = [81 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 65 , 0 , 0 , 0 , 53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn udt_script (& self) -> Script { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Script :: new_unchecked (self . 0 . slice (start .. end)) } pub fn amount (& self) -> Uint128 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint128 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint128 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> UDTAssetReader < 'r > { UDTAssetReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UDTAsset { type Builder = UDTAssetBuilder ; const NAME : & 'static str = "UDTAsset" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UDTAsset (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UDTAssetReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UDTAssetReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . udt_script (self . udt_script ()) . amount (self . amount ()) } }
# [derive (Clone , Copy)] pub struct UDTAssetReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UDTAssetReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UDTAssetReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UDTAssetReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "udt_script" , self . udt_script ()) ? ; write ! (f , ", {}: {}" , "amount" , self . amount ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > UDTAssetReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn udt_script (& self) -> ScriptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; ScriptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn amount (& self) -> Uint128Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint128Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint128Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UDTAssetReader < 'r > { type Entity = UDTAsset ; const NAME : & 'static str = "UDTAssetReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UDTAssetReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } ScriptReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint128Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UDTAssetBuilder { pub (crate) udt_script : Script , pub (crate) amount : Uint128 , } impl UDTAssetBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn udt_script < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Script > { self . udt_script = v . into () ; self } pub fn amount < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint128 > { self . amount = v . into () ; self } } impl molecule :: prelude :: Builder for UDTAssetBuilder { type Entity = UDTAsset ; const NAME : & 'static str = "UDTAssetBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . udt_script . as_slice () . len () + self . amount . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . udt_script . as_slice () . len () ; offsets . push (total_size) ; total_size += self . amount . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . udt_script . as_slice ()) ? ; writer . write_all (self . amount . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UDTAsset :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct UDTAssetVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UDTAssetVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UDTAssetVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UDTAssetVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for UDTAssetVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UDTAssetVec :: new_unchecked (v) } } impl UDTAssetVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UDTAsset > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UDTAsset { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UDTAsset :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UDTAsset :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> UDTAssetVecReader < 'r > { UDTAssetVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UDTAssetVec { type Builder = UDTAssetVecBuilder ; const NAME : & 'static str = "UDTAssetVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UDTAssetVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UDTAssetVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UDTAssetVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct UDTAssetVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UDTAssetVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UDTAssetVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UDTAssetVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > UDTAssetVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UDTAssetReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UDTAssetReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UDTAssetReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UDTAssetReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UDTAssetVecReader < 'r > { type Entity = UDTAssetVec ; const NAME : & 'static str = "UDTAssetVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UDTAssetVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; UDTAssetReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UDTAssetVecBuilder (pub (crate) Vec < UDTAsset >) ; impl UDTAssetVecBuilder { pub fn set (mut self , v : Vec < UDTAsset >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UDTAsset > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = UDTAsset >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < UDTAsset > where T : :: core :: convert :: Into < UDTAsset > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for UDTAssetVecBuilder { type Entity = UDTAssetVec ; const NAME : & 'static str = "UDTAssetVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UDTAssetVec :: new_unchecked (inner . into ()) } }
pub struct UDTAssetVecIterator (UDTAssetVec , usize , usize) ; impl :: core :: iter :: Iterator for UDTAssetVecIterator { type Item = UDTAsset ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for UDTAssetVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for UDTAssetVec { type Item = UDTAsset ; type IntoIter = UDTAssetVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; UDTAssetVecIterator (self , 0 , len) } } impl < 'r > UDTAssetVecReader < 'r > { pub fn iter < 't > (& 't self) -> UDTAssetVecReaderIterator < 't , 'r > { UDTAssetVecReaderIterator (& self , 0 , self . len ()) } } pub struct UDTAssetVecReaderIterator < 't , 'r > (& 't UDTAssetVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for UDTAssetVecReaderIterator < 't , 'r > { type Item = UDTAssetReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for UDTAssetVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < UDTAsset > for UDTAssetVec { fn from_iter < T : IntoIterator < Item = UDTAsset >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < UDTAsset >> for UDTAssetVec { fn from (v : Vec < UDTAsset >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct AssetList (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for AssetList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for AssetList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for AssetList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "points_amount" , self . points_amount ()) ? ; write ! (f , ", {}: {}" , "ckb_amount" , self . ckb_amount ()) ? ; write ! (f , ", {}: {}" , "nft_assets" , self . nft_assets ()) ? ; write ! (f , ", {}: {}" , "udt_assets" , self . udt_assets ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for AssetList { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; AssetList :: new_unchecked (v) } } impl AssetList { const DEFAULT_VALUE : [u8 ; 44] = [44 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn points_amount (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ckb_amount (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn nft_assets (& self) -> ScriptVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; ScriptVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn udt_assets (& self) -> UDTAssetVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; UDTAssetVec :: new_unchecked (self . 0 . slice (start .. end)) } else { UDTAssetVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> AssetListReader < 'r > { AssetListReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for AssetList { type Builder = AssetListBuilder ; const NAME : & 'static str = "AssetList" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { AssetList (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AssetListReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AssetListReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . points_amount (self . points_amount ()) . ckb_amount (self . ckb_amount ()) . nft_assets (self . nft_assets ()) . udt_assets (self . udt_assets ()) } }
# [derive (Clone , Copy)] pub struct AssetListReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for AssetListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for AssetListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for AssetListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "points_amount" , self . points_amount ()) ? ; write ! (f , ", {}: {}" , "ckb_amount" , self . ckb_amount ()) ? ; write ! (f , ", {}: {}" , "nft_assets" , self . nft_assets ()) ? ; write ! (f , ", {}: {}" , "udt_assets" , self . udt_assets ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > AssetListReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn points_amount (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ckb_amount (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn nft_assets (& self) -> ScriptVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; ScriptVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn udt_assets (& self) -> UDTAssetVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; UDTAssetVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { UDTAssetVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for AssetListReader < 'r > { type Entity = AssetList ; const NAME : & 'static str = "AssetListReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { AssetListReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint64Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; ScriptVecReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; UDTAssetVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct AssetListBuilder { pub (crate) points_amount : Uint64 , pub (crate) ckb_amount : Uint64 , pub (crate) nft_assets : ScriptVec , pub (crate) udt_assets : UDTAssetVec , } impl AssetListBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn points_amount < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . points_amount = v . into () ; self } pub fn ckb_amount < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . ckb_amount = v . into () ; self } pub fn nft_assets < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ScriptVec > { self . nft_assets = v . into () ; self } pub fn udt_assets < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UDTAssetVec > { self . udt_assets = v . into () ; self } } impl molecule :: prelude :: Builder for AssetListBuilder { type Entity = AssetList ; const NAME : & 'static str = "AssetListBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . points_amount . as_slice () . len () + self . ckb_amount . as_slice () . len () + self . nft_assets . as_slice () . len () + self . udt_assets . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . points_amount . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ckb_amount . as_slice () . len () ; offsets . push (total_size) ; total_size += self . nft_assets . as_slice () . len () ; offsets . push (total_size) ; total_size += self . udt_assets . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . points_amount . as_slice ()) ? ; writer . write_all (self . ckb_amount . as_slice ()) ? ; writer . write_all (self . nft_assets . as_slice ()) ? ; writer . write_all (self . udt_assets . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; AssetList :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct AssetListVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for AssetListVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for AssetListVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for AssetListVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for AssetListVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; AssetListVec :: new_unchecked (v) } } impl AssetListVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < AssetList > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> AssetList { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { AssetList :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; AssetList :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> AssetListVecReader < 'r > { AssetListVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for AssetListVec { type Builder = AssetListVecBuilder ; const NAME : & 'static str = "AssetListVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { AssetListVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AssetListVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { AssetListVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct AssetListVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for AssetListVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for AssetListVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for AssetListVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > AssetListVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < AssetListReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> AssetListReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { AssetListReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; AssetListReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for AssetListVecReader < 'r > { type Entity = AssetListVec ; const NAME : & 'static str = "AssetListVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { AssetListVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; AssetListReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct AssetListVecBuilder (pub (crate) Vec < AssetList >) ; impl AssetListVecBuilder { pub fn set (mut self , v : Vec < AssetList >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < AssetList > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = AssetList >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < AssetList > where T : :: core :: convert :: Into < AssetList > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for AssetListVecBuilder { type Entity = AssetListVec ; const NAME : & 'static str = "AssetListVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; AssetListVec :: new_unchecked (inner . into ()) } }
pub struct AssetListVecIterator (AssetListVec , usize , usize) ; impl :: core :: iter :: Iterator for AssetListVecIterator { type Item = AssetList ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for AssetListVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for AssetListVec { type Item = AssetList ; type IntoIter = AssetListVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; AssetListVecIterator (self , 0 , len) } } impl < 'r > AssetListVecReader < 'r > { pub fn iter < 't > (& 't self) -> AssetListVecReaderIterator < 't , 'r > { AssetListVecReaderIterator (& self , 0 , self . len ()) } } pub struct AssetListVecReaderIterator < 't , 'r > (& 't AssetListVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for AssetListVecReaderIterator < 't , 'r > { type Item = AssetListReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for AssetListVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < AssetList > for AssetListVec { fn from_iter < T : IntoIterator < Item = AssetList >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < AssetList >> for AssetListVec { fn from (v : Vec < AssetList >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct QuestSubTaskData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for QuestSubTaskData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for QuestSubTaskData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for QuestSubTaskData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "id" , self . id ()) ? ; write ! (f , ", {}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "type" , self . type_ ()) ? ; write ! (f , ", {}: {}" , "description" , self . description ()) ? ; write ! (f , ", {}: {}" , "proof_required" , self . proof_required ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for QuestSubTaskData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; QuestSubTaskData :: new_unchecked (v) } } impl QuestSubTaskData { const DEFAULT_VALUE : [u8 ; 41] = [41 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 25 , 0 , 0 , 0 , 29 , 0 , 0 , 0 , 33 , 0 , 0 , 0 , 37 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 5 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn id (& self) -> Uint8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn title (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn type_ (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proof_required (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [24 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } else { String :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> QuestSubTaskDataReader < 'r > { QuestSubTaskDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for QuestSubTaskData { type Builder = QuestSubTaskDataBuilder ; const NAME : & 'static str = "QuestSubTaskData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { QuestSubTaskData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestSubTaskDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestSubTaskDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . id (self . id ()) . title (self . title ()) . type_ (self . type_ ()) . description (self . description ()) . proof_required (self . proof_required ()) } }
# [derive (Clone , Copy)] pub struct QuestSubTaskDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for QuestSubTaskDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for QuestSubTaskDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for QuestSubTaskDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "id" , self . id ()) ? ; write ! (f , ", {}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "type" , self . type_ ()) ? ; write ! (f , ", {}: {}" , "description" , self . description ()) ? ; write ! (f , ", {}: {}" , "proof_required" , self . proof_required ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > QuestSubTaskDataReader < 'r > { pub const FIELD_COUNT : usize = 5 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn id (& self) -> Uint8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn title (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn type_ (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proof_required (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [24 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } else { StringReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for QuestSubTaskDataReader < 'r > { type Entity = QuestSubTaskData ; const NAME : & 'static str = "QuestSubTaskDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { QuestSubTaskDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint8Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; StringReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; StringReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; StringReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; StringReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct QuestSubTaskDataBuilder { pub (crate) id : Uint8 , pub (crate) title : String , pub (crate) type_ : String , pub (crate) description : String , pub (crate) proof_required : String , } impl QuestSubTaskDataBuilder { pub const FIELD_COUNT : usize = 5 ; pub fn id < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8 > { self . id = v . into () ; self } pub fn title < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . title = v . into () ; self } pub fn type_ < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . type_ = v . into () ; self } pub fn description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . description = v . into () ; self } pub fn proof_required < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . proof_required = v . into () ; self } } impl molecule :: prelude :: Builder for QuestSubTaskDataBuilder { type Entity = QuestSubTaskData ; const NAME : & 'static str = "QuestSubTaskDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . id . as_slice () . len () + self . title . as_slice () . len () + self . type_ . as_slice () . len () + self . description . as_slice () . len () + self . proof_required . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . id . as_slice () . len () ; offsets . push (total_size) ; total_size += self . title . as_slice () . len () ; offsets . push (total_size) ; total_size += self . type_ . as_slice () . len () ; offsets . push (total_size) ; total_size += self . description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proof_required . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . id . as_slice ()) ? ; writer . write_all (self . title . as_slice ()) ? ; writer . write_all (self . type_ . as_slice ()) ? ; writer . write_all (self . description . as_slice ()) ? ; writer . write_all (self . proof_required . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; QuestSubTaskData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct QuestSubTaskDataVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for QuestSubTaskDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for QuestSubTaskDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for QuestSubTaskDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for QuestSubTaskDataVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; QuestSubTaskDataVec :: new_unchecked (v) } } impl QuestSubTaskDataVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < QuestSubTaskData > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> QuestSubTaskData { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { QuestSubTaskData :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; QuestSubTaskData :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> QuestSubTaskDataVecReader < 'r > { QuestSubTaskDataVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for QuestSubTaskDataVec { type Builder = QuestSubTaskDataVecBuilder ; const NAME : & 'static str = "QuestSubTaskDataVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { QuestSubTaskDataVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestSubTaskDataVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestSubTaskDataVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct QuestSubTaskDataVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for QuestSubTaskDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for QuestSubTaskDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for QuestSubTaskDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > QuestSubTaskDataVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < QuestSubTaskDataReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> QuestSubTaskDataReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { QuestSubTaskDataReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; QuestSubTaskDataReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for QuestSubTaskDataVecReader < 'r > { type Entity = QuestSubTaskDataVec ; const NAME : & 'static str = "QuestSubTaskDataVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { QuestSubTaskDataVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; QuestSubTaskDataReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct QuestSubTaskDataVecBuilder (pub (crate) Vec < QuestSubTaskData >) ; impl QuestSubTaskDataVecBuilder { pub fn set (mut self , v : Vec < QuestSubTaskData >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < QuestSubTaskData > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = QuestSubTaskData >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < QuestSubTaskData > where T : :: core :: convert :: Into < QuestSubTaskData > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for QuestSubTaskDataVecBuilder { type Entity = QuestSubTaskDataVec ; const NAME : & 'static str = "QuestSubTaskDataVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; QuestSubTaskDataVec :: new_unchecked (inner . into ()) } }
pub struct QuestSubTaskDataVecIterator (QuestSubTaskDataVec , usize , usize) ; impl :: core :: iter :: Iterator for QuestSubTaskDataVecIterator { type Item = QuestSubTaskData ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for QuestSubTaskDataVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for QuestSubTaskDataVec { type Item = QuestSubTaskData ; type IntoIter = QuestSubTaskDataVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; QuestSubTaskDataVecIterator (self , 0 , len) } } impl < 'r > QuestSubTaskDataVecReader < 'r > { pub fn iter < 't > (& 't self) -> QuestSubTaskDataVecReaderIterator < 't , 'r > { QuestSubTaskDataVecReaderIterator (& self , 0 , self . len ()) } } pub struct QuestSubTaskDataVecReaderIterator < 't , 'r > (& 't QuestSubTaskDataVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for QuestSubTaskDataVecReaderIterator < 't , 'r > { type Item = QuestSubTaskDataReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for QuestSubTaskDataVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < QuestSubTaskData > for QuestSubTaskDataVec { fn from_iter < T : IntoIterator < Item = QuestSubTaskData >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < QuestSubTaskData >> for QuestSubTaskDataVec { fn from (v : Vec < QuestSubTaskData >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct QuestMetadata (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for QuestMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for QuestMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for QuestMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "short_description" , self . short_description ()) ? ; write ! (f , ", {}: {}" , "long_description" , self . long_description ()) ? ; write ! (f , ", {}: {}" , "requirements" , self . requirements ()) ? ; write ! (f , ", {}: {}" , "difficulty" , self . difficulty ()) ? ; write ! (f , ", {}: {}" , "time_estimate" , self . time_estimate ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for QuestMetadata { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; QuestMetadata :: new_unchecked (v) } } impl QuestMetadata { const DEFAULT_VALUE : [u8 ; 49] = [49 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 45 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn title (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn short_description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn long_description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn requirements (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn difficulty (& self) -> Uint8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn time_estimate (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint32 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> QuestMetadataReader < 'r > { QuestMetadataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for QuestMetadata { type Builder = QuestMetadataBuilder ; const NAME : & 'static str = "QuestMetadata" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { QuestMetadata (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestMetadataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestMetadataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . title (self . title ()) . short_description (self . short_description ()) . long_description (self . long_description ()) . requirements (self . requirements ()) . difficulty (self . difficulty ()) . time_estimate (self . time_estimate ()) } }
# [derive (Clone , Copy)] pub struct QuestMetadataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for QuestMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for QuestMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for QuestMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "short_description" , self . short_description ()) ? ; write ! (f , ", {}: {}" , "long_description" , self . long_description ()) ? ; write ! (f , ", {}: {}" , "requirements" , self . requirements ()) ? ; write ! (f , ", {}: {}" , "difficulty" , self . difficulty ()) ? ; write ! (f , ", {}: {}" , "time_estimate" , self . time_estimate ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > QuestMetadataReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn title (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn short_description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn long_description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn requirements (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn difficulty (& self) -> Uint8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn time_estimate (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint32Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for QuestMetadataReader < 'r > { type Entity = QuestMetadata ; const NAME : & 'static str = "QuestMetadataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { QuestMetadataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } StringReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; StringReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; StringReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; StringReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Uint8Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct QuestMetadataBuilder { pub (crate) title : String , pub (crate) short_description : String , pub (crate) long_description : String , pub (crate) requirements : String , pub (crate) difficulty : Uint8 , pub (crate) time_estimate : Uint32 , } impl QuestMetadataBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn title < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . title = v . into () ; self } pub fn short_description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . short_description = v . into () ; self } pub fn long_description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . long_description = v . into () ; self } pub fn requirements < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . requirements = v . into () ; self } pub fn difficulty < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8 > { self . difficulty = v . into () ; self } pub fn time_estimate < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . time_estimate = v . into () ; self } } impl molecule :: prelude :: Builder for QuestMetadataBuilder { type Entity = QuestMetadata ; const NAME : & 'static str = "QuestMetadataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . title . as_slice () . len () + self . short_description . as_slice () . len () + self . long_description . as_slice () . len () + self . requirements . as_slice () . len () + self . difficulty . as_slice () . len () + self . time_estimate . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . title . as_slice () . len () ; offsets . push (total_size) ; total_size += self . short_description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . long_description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . requirements . as_slice () . len () ; offsets . push (total_size) ; total_size += self . difficulty . as_slice () . len () ; offsets . push (total_size) ; total_size += self . time_estimate . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . title . as_slice ()) ? ; writer . write_all (self . short_description . as_slice ()) ? ; writer . write_all (self . long_description . as_slice ()) ? ; writer . write_all (self . requirements . as_slice ()) ? ; writer . write_all (self . difficulty . as_slice ()) ? ; writer . write_all (self . time_estimate . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; QuestMetadata :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct QuestData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for QuestData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for QuestData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for QuestData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "quest_id" , self . quest_id ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "rewards_on_completion" , self . rewards_on_completion ()) ? ; write ! (f , ", {}: {}" , "accepted_submission_user_type_ids" , self . accepted_submission_user_type_ids ()) ? ; write ! (f , ", {}: {}" , "completion_deadline" , self . completion_deadline ()) ? ; write ! (f , ", {}: {}" , "status" , self . status ()) ? ; write ! (f , ", {}: {}" , "sub_tasks" , self . sub_tasks ()) ? ; write ! (f , ", {}: {}" , "points" , self . points ()) ? ; write ! (f , ", {}: {}" , "completion_count" , self . completion_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for QuestData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; QuestData :: new_unchecked (v) } } impl QuestData { const DEFAULT_VALUE : [u8 ; 122] = [122 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 93 , 0 , 0 , 0 , 97 , 0 , 0 , 0 , 101 , 0 , 0 , 0 , 109 , 0 , 0 , 0 , 110 , 0 , 0 , 0 , 114 , 0 , 0 , 0 , 118 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 45 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 9 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn quest_id (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn metadata (& self) -> QuestMetadata { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; QuestMetadata :: new_unchecked (self . 0 . slice (start .. end)) } pub fn rewards_on_completion (& self) -> AssetListVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; AssetListVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn accepted_submission_user_type_ids (& self) -> Byte32Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte32Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn completion_deadline (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn status (& self) -> Byte { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn sub_tasks (& self) -> QuestSubTaskDataVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; QuestSubTaskDataVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn points (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn completion_count (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint32 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> QuestDataReader < 'r > { QuestDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for QuestData { type Builder = QuestDataBuilder ; const NAME : & 'static str = "QuestData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { QuestData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . quest_id (self . quest_id ()) . metadata (self . metadata ()) . rewards_on_completion (self . rewards_on_completion ()) . accepted_submission_user_type_ids (self . accepted_submission_user_type_ids ()) . completion_deadline (self . completion_deadline ()) . status (self . status ()) . sub_tasks (self . sub_tasks ()) . points (self . points ()) . completion_count (self . completion_count ()) } }
# [derive (Clone , Copy)] pub struct QuestDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for QuestDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for QuestDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for QuestDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "quest_id" , self . quest_id ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "rewards_on_completion" , self . rewards_on_completion ()) ? ; write ! (f , ", {}: {}" , "accepted_submission_user_type_ids" , self . accepted_submission_user_type_ids ()) ? ; write ! (f , ", {}: {}" , "completion_deadline" , self . completion_deadline ()) ? ; write ! (f , ", {}: {}" , "status" , self . status ()) ? ; write ! (f , ", {}: {}" , "sub_tasks" , self . sub_tasks ()) ? ; write ! (f , ", {}: {}" , "points" , self . points ()) ? ; write ! (f , ", {}: {}" , "completion_count" , self . completion_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > QuestDataReader < 'r > { pub const FIELD_COUNT : usize = 9 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn quest_id (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn metadata (& self) -> QuestMetadataReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; QuestMetadataReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn rewards_on_completion (& self) -> AssetListVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; AssetListVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn accepted_submission_user_type_ids (& self) -> Byte32VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte32VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn completion_deadline (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn status (& self) -> ByteReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn sub_tasks (& self) -> QuestSubTaskDataVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; QuestSubTaskDataVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn points (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn completion_count (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint32Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for QuestDataReader < 'r > { type Entity = QuestData ; const NAME : & 'static str = "QuestDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { QuestDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; QuestMetadataReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; AssetListVecReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Byte32VecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; ByteReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; QuestSubTaskDataVecReader :: verify (& slice [offsets [6] .. offsets [7]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [7] .. offsets [8]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [8] .. offsets [9]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct QuestDataBuilder { pub (crate) quest_id : Uint32 , pub (crate) metadata : QuestMetadata , pub (crate) rewards_on_completion : AssetListVec , pub (crate) accepted_submission_user_type_ids : Byte32Vec , pub (crate) completion_deadline : Uint64 , pub (crate) status : Byte , pub (crate) sub_tasks : QuestSubTaskDataVec , pub (crate) points : Uint32 , pub (crate) completion_count : Uint32 , } impl QuestDataBuilder { pub const FIELD_COUNT : usize = 9 ; pub fn quest_id < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . quest_id = v . into () ; self } pub fn metadata < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < QuestMetadata > { self . metadata = v . into () ; self } pub fn rewards_on_completion < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < AssetListVec > { self . rewards_on_completion = v . into () ; self } pub fn accepted_submission_user_type_ids < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Vec > { self . accepted_submission_user_type_ids = v . into () ; self } pub fn completion_deadline < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . completion_deadline = v . into () ; self } pub fn status < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . status = v . into () ; self } pub fn sub_tasks < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < QuestSubTaskDataVec > { self . sub_tasks = v . into () ; self } pub fn points < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . points = v . into () ; self } pub fn completion_count < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . completion_count = v . into () ; self } } impl molecule :: prelude :: Builder for QuestDataBuilder { type Entity = QuestData ; const NAME : & 'static str = "QuestDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . quest_id . as_slice () . len () + self . metadata . as_slice () . len () + self . rewards_on_completion . as_slice () . len () + self . accepted_submission_user_type_ids . as_slice () . len () + self . completion_deadline . as_slice () . len () + self . status . as_slice () . len () + self . sub_tasks . as_slice () . len () + self . points . as_slice () . len () + self . completion_count . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . quest_id . as_slice () . len () ; offsets . push (total_size) ; total_size += self . metadata . as_slice () . len () ; offsets . push (total_size) ; total_size += self . rewards_on_completion . as_slice () . len () ; offsets . push (total_size) ; total_size += self . accepted_submission_user_type_ids . as_slice () . len () ; offsets . push (total_size) ; total_size += self . completion_deadline . as_slice () . len () ; offsets . push (total_size) ; total_size += self . status . as_slice () . len () ; offsets . push (total_size) ; total_size += self . sub_tasks . as_slice () . len () ; offsets . push (total_size) ; total_size += self . points . as_slice () . len () ; offsets . push (total_size) ; total_size += self . completion_count . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . quest_id . as_slice ()) ? ; writer . write_all (self . metadata . as_slice ()) ? ; writer . write_all (self . rewards_on_completion . as_slice ()) ? ; writer . write_all (self . accepted_submission_user_type_ids . as_slice ()) ? ; writer . write_all (self . completion_deadline . as_slice ()) ? ; writer . write_all (self . status . as_slice ()) ? ; writer . write_all (self . sub_tasks . as_slice ()) ? ; writer . write_all (self . points . as_slice ()) ? ; writer . write_all (self . completion_count . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; QuestData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct QuestDataVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for QuestDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for QuestDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for QuestDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for QuestDataVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; QuestDataVec :: new_unchecked (v) } } impl QuestDataVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < QuestData > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> QuestData { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { QuestData :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; QuestData :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> QuestDataVecReader < 'r > { QuestDataVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for QuestDataVec { type Builder = QuestDataVecBuilder ; const NAME : & 'static str = "QuestDataVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { QuestDataVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestDataVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { QuestDataVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct QuestDataVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for QuestDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for QuestDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for QuestDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > QuestDataVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < QuestDataReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> QuestDataReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { QuestDataReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; QuestDataReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for QuestDataVecReader < 'r > { type Entity = QuestDataVec ; const NAME : & 'static str = "QuestDataVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { QuestDataVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; QuestDataReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct QuestDataVecBuilder (pub (crate) Vec < QuestData >) ; impl QuestDataVecBuilder { pub fn set (mut self , v : Vec < QuestData >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < QuestData > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = QuestData >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < QuestData > where T : :: core :: convert :: Into < QuestData > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for QuestDataVecBuilder { type Entity = QuestDataVec ; const NAME : & 'static str = "QuestDataVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; QuestDataVec :: new_unchecked (inner . into ()) } }
pub struct QuestDataVecIterator (QuestDataVec , usize , usize) ; impl :: core :: iter :: Iterator for QuestDataVecIterator { type Item = QuestData ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for QuestDataVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for QuestDataVec { type Item = QuestData ; type IntoIter = QuestDataVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; QuestDataVecIterator (self , 0 , len) } } impl < 'r > QuestDataVecReader < 'r > { pub fn iter < 't > (& 't self) -> QuestDataVecReaderIterator < 't , 'r > { QuestDataVecReaderIterator (& self , 0 , self . len ()) } } pub struct QuestDataVecReaderIterator < 't , 'r > (& 't QuestDataVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for QuestDataVecReaderIterator < 't , 'r > { type Item = QuestDataReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for QuestDataVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < QuestData > for QuestDataVec { fn from_iter < T : IntoIterator < Item = QuestData >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < QuestData >> for QuestDataVec { fn from (v : Vec < QuestData >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct CampaignMetadata (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CampaignMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CampaignMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CampaignMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "endorser_info" , self . endorser_info ()) ? ; write ! (f , ", {}: {}" , "short_description" , self . short_description ()) ? ; write ! (f , ", {}: {}" , "long_description" , self . long_description ()) ? ; write ! (f , ", {}: {}" , "total_rewards" , self . total_rewards ()) ? ; write ! (f , ", {}: {}" , "verification_requirements" , self . verification_requirements ()) ? ; write ! (f , ", {}: {}" , "last_updated" , self . last_updated ()) ? ; write ! (f , ", {}: {}" , "categories" , self . categories ()) ? ; write ! (f , ", {}: {}" , "difficulty" , self . difficulty ()) ? ; write ! (f , ", {}: {}" , "image_url" , self . image_url ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for CampaignMetadata { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CampaignMetadata :: new_unchecked (v) } } impl CampaignMetadata { const DEFAULT_VALUE : [u8 ; 198] = [198 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 125 , 0 , 0 , 0 , 129 , 0 , 0 , 0 , 133 , 0 , 0 , 0 , 177 , 0 , 0 , 0 , 181 , 0 , 0 , 0 , 189 , 0 , 0 , 0 , 193 , 0 , 0 , 0 , 194 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 77 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 68 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 76 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn title (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn endorser_info (& self) -> EndorserInfo { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; EndorserInfo :: new_unchecked (self . 0 . slice (start .. end)) } pub fn short_description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn long_description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn total_rewards (& self) -> AssetList { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; AssetList :: new_unchecked (self . 0 . slice (start .. end)) } pub fn verification_requirements (& self) -> Uint8Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint8Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn last_updated (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn categories (& self) -> StringVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; StringVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn difficulty (& self) -> Uint8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn image_url (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [44 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } else { String :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> CampaignMetadataReader < 'r > { CampaignMetadataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CampaignMetadata { type Builder = CampaignMetadataBuilder ; const NAME : & 'static str = "CampaignMetadata" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CampaignMetadata (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignMetadataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignMetadataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . title (self . title ()) . endorser_info (self . endorser_info ()) . short_description (self . short_description ()) . long_description (self . long_description ()) . total_rewards (self . total_rewards ()) . verification_requirements (self . verification_requirements ()) . last_updated (self . last_updated ()) . categories (self . categories ()) . difficulty (self . difficulty ()) . image_url (self . image_url ()) } }
# [derive (Clone , Copy)] pub struct CampaignMetadataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CampaignMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CampaignMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CampaignMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "title" , self . title ()) ? ; write ! (f , ", {}: {}" , "endorser_info" , self . endorser_info ()) ? ; write ! (f , ", {}: {}" , "short_description" , self . short_description ()) ? ; write ! (f , ", {}: {}" , "long_description" , self . long_description ()) ? ; write ! (f , ", {}: {}" , "total_rewards" , self . total_rewards ()) ? ; write ! (f , ", {}: {}" , "verification_requirements" , self . verification_requirements ()) ? ; write ! (f , ", {}: {}" , "last_updated" , self . last_updated ()) ? ; write ! (f , ", {}: {}" , "categories" , self . categories ()) ? ; write ! (f , ", {}: {}" , "difficulty" , self . difficulty ()) ? ; write ! (f , ", {}: {}" , "image_url" , self . image_url ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > CampaignMetadataReader < 'r > { pub const FIELD_COUNT : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn title (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn endorser_info (& self) -> EndorserInfoReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; EndorserInfoReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn short_description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn long_description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn total_rewards (& self) -> AssetListReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; AssetListReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn verification_requirements (& self) -> Uint8VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint8VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn last_updated (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn categories (& self) -> StringVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; StringVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn difficulty (& self) -> Uint8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn image_url (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [44 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } else { StringReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CampaignMetadataReader < 'r > { type Entity = CampaignMetadata ; const NAME : & 'static str = "CampaignMetadataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CampaignMetadataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } StringReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; EndorserInfoReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; StringReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; StringReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; AssetListReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Uint8VecReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [6] .. offsets [7]] , compatible) ? ; StringVecReader :: verify (& slice [offsets [7] .. offsets [8]] , compatible) ? ; Uint8Reader :: verify (& slice [offsets [8] .. offsets [9]] , compatible) ? ; StringReader :: verify (& slice [offsets [9] .. offsets [10]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CampaignMetadataBuilder { pub (crate) title : String , pub (crate) endorser_info : EndorserInfo , pub (crate) short_description : String , pub (crate) long_description : String , pub (crate) total_rewards : AssetList , pub (crate) verification_requirements : Uint8Vec , pub (crate) last_updated : Uint64 , pub (crate) categories : StringVec , pub (crate) difficulty : Uint8 , pub (crate) image_url : String , } impl CampaignMetadataBuilder { pub const FIELD_COUNT : usize = 10 ; pub fn title < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . title = v . into () ; self } pub fn endorser_info < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < EndorserInfo > { self . endorser_info = v . into () ; self } pub fn short_description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . short_description = v . into () ; self } pub fn long_description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . long_description = v . into () ; self } pub fn total_rewards < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < AssetList > { self . total_rewards = v . into () ; self } pub fn verification_requirements < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8Vec > { self . verification_requirements = v . into () ; self } pub fn last_updated < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . last_updated = v . into () ; self } pub fn categories < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < StringVec > { self . categories = v . into () ; self } pub fn difficulty < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8 > { self . difficulty = v . into () ; self } pub fn image_url < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . image_url = v . into () ; self } } impl molecule :: prelude :: Builder for CampaignMetadataBuilder { type Entity = CampaignMetadata ; const NAME : & 'static str = "CampaignMetadataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . title . as_slice () . len () + self . endorser_info . as_slice () . len () + self . short_description . as_slice () . len () + self . long_description . as_slice () . len () + self . total_rewards . as_slice () . len () + self . verification_requirements . as_slice () . len () + self . last_updated . as_slice () . len () + self . categories . as_slice () . len () + self . difficulty . as_slice () . len () + self . image_url . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . title . as_slice () . len () ; offsets . push (total_size) ; total_size += self . endorser_info . as_slice () . len () ; offsets . push (total_size) ; total_size += self . short_description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . long_description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . total_rewards . as_slice () . len () ; offsets . push (total_size) ; total_size += self . verification_requirements . as_slice () . len () ; offsets . push (total_size) ; total_size += self . last_updated . as_slice () . len () ; offsets . push (total_size) ; total_size += self . categories . as_slice () . len () ; offsets . push (total_size) ; total_size += self . difficulty . as_slice () . len () ; offsets . push (total_size) ; total_size += self . image_url . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . title . as_slice ()) ? ; writer . write_all (self . endorser_info . as_slice ()) ? ; writer . write_all (self . short_description . as_slice ()) ? ; writer . write_all (self . long_description . as_slice ()) ? ; writer . write_all (self . total_rewards . as_slice ()) ? ; writer . write_all (self . verification_requirements . as_slice ()) ? ; writer . write_all (self . last_updated . as_slice ()) ? ; writer . write_all (self . categories . as_slice ()) ? ; writer . write_all (self . difficulty . as_slice ()) ? ; writer . write_all (self . image_url . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CampaignMetadata :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CampaignData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CampaignData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CampaignData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CampaignData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "endorser" , self . endorser ()) ? ; write ! (f , ", {}: {}" , "created_at" , self . created_at ()) ? ; write ! (f , ", {}: {}" , "starting_time" , self . starting_time ()) ? ; write ! (f , ", {}: {}" , "ending_time" , self . ending_time ()) ? ; write ! (f , ", {}: {}" , "rules" , self . rules ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "status" , self . status ()) ? ; write ! (f , ", {}: {}" , "quests" , self . quests ()) ? ; write ! (f , ", {}: {}" , "participants_count" , self . participants_count ()) ? ; write ! (f , ", {}: {}" , "total_completions" , self . total_completions ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for CampaignData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CampaignData :: new_unchecked (v) } } impl CampaignData { const DEFAULT_VALUE : [u8 ; 360] = [104 , 1 , 0 , 0 , 44 , 0 , 0 , 0 , 121 , 0 , 0 , 0 , 129 , 0 , 0 , 0 , 137 , 0 , 0 , 0 , 145 , 0 , 0 , 0 , 149 , 0 , 0 , 0 , 91 , 1 , 0 , 0 , 92 , 1 , 0 , 0 , 96 , 1 , 0 , 0 , 100 , 1 , 0 , 0 , 77 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 68 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 76 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 198 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 125 , 0 , 0 , 0 , 129 , 0 , 0 , 0 , 133 , 0 , 0 , 0 , 177 , 0 , 0 , 0 , 181 , 0 , 0 , 0 , 189 , 0 , 0 , 0 , 193 , 0 , 0 , 0 , 194 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 77 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 68 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 76 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn endorser (& self) -> EndorserInfo { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; EndorserInfo :: new_unchecked (self . 0 . slice (start .. end)) } pub fn created_at (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn starting_time (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ending_time (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn rules (& self) -> StringVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; StringVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn metadata (& self) -> CampaignMetadata { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; CampaignMetadata :: new_unchecked (self . 0 . slice (start .. end)) } pub fn status (& self) -> Byte { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn quests (& self) -> QuestDataVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; QuestDataVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn participants_count (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn total_completions (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [44 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint32 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> CampaignDataReader < 'r > { CampaignDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CampaignData { type Builder = CampaignDataBuilder ; const NAME : & 'static str = "CampaignData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CampaignData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . endorser (self . endorser ()) . created_at (self . created_at ()) . starting_time (self . starting_time ()) . ending_time (self . ending_time ()) . rules (self . rules ()) . metadata (self . metadata ()) . status (self . status ()) . quests (self . quests ()) . participants_count (self . participants_count ()) . total_completions (self . total_completions ()) } }
# [derive (Clone , Copy)] pub struct CampaignDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CampaignDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CampaignDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CampaignDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "endorser" , self . endorser ()) ? ; write ! (f , ", {}: {}" , "created_at" , self . created_at ()) ? ; write ! (f , ", {}: {}" , "starting_time" , self . starting_time ()) ? ; write ! (f , ", {}: {}" , "ending_time" , self . ending_time ()) ? ; write ! (f , ", {}: {}" , "rules" , self . rules ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "status" , self . status ()) ? ; write ! (f , ", {}: {}" , "quests" , self . quests ()) ? ; write ! (f , ", {}: {}" , "participants_count" , self . participants_count ()) ? ; write ! (f , ", {}: {}" , "total_completions" , self . total_completions ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > CampaignDataReader < 'r > { pub const FIELD_COUNT : usize = 10 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn endorser (& self) -> EndorserInfoReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; EndorserInfoReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn created_at (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn starting_time (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ending_time (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn rules (& self) -> StringVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; StringVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn metadata (& self) -> CampaignMetadataReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; CampaignMetadataReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn status (& self) -> ByteReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn quests (& self) -> QuestDataVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; QuestDataVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn participants_count (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn total_completions (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [44 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint32Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CampaignDataReader < 'r > { type Entity = CampaignData ; const NAME : & 'static str = "CampaignDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CampaignDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } EndorserInfoReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; StringVecReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; CampaignMetadataReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; ByteReader :: verify (& slice [offsets [6] .. offsets [7]] , compatible) ? ; QuestDataVecReader :: verify (& slice [offsets [7] .. offsets [8]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [8] .. offsets [9]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [9] .. offsets [10]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CampaignDataBuilder { pub (crate) endorser : EndorserInfo , pub (crate) created_at : Uint64 , pub (crate) starting_time : Uint64 , pub (crate) ending_time : Uint64 , pub (crate) rules : StringVec , pub (crate) metadata : CampaignMetadata , pub (crate) status : Byte , pub (crate) quests : QuestDataVec , pub (crate) participants_count : Uint32 , pub (crate) total_completions : Uint32 , } impl CampaignDataBuilder { pub const FIELD_COUNT : usize = 10 ; pub fn endorser < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < EndorserInfo > { self . endorser = v . into () ; self } pub fn created_at < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . created_at = v . into () ; self } pub fn starting_time < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . starting_time = v . into () ; self } pub fn ending_time < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . ending_time = v . into () ; self } pub fn rules < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < StringVec > { self . rules = v . into () ; self } pub fn metadata < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CampaignMetadata > { self . metadata = v . into () ; self } pub fn status < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte > { self . status = v . into () ; self } pub fn quests < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < QuestDataVec > { self . quests = v . into () ; self } pub fn participants_count < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . participants_count = v . into () ; self } pub fn total_completions < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . total_completions = v . into () ; self } } impl molecule :: prelude :: Builder for CampaignDataBuilder { type Entity = CampaignData ; const NAME : & 'static str = "CampaignDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . endorser . as_slice () . len () + self . created_at . as_slice () . len () + self . starting_time . as_slice () . len () + self . ending_time . as_slice () . len () + self . rules . as_slice () . len () + self . metadata . as_slice () . len () + self . status . as_slice () . len () + self . quests . as_slice () . len () + self . participants_count . as_slice () . len () + self . total_completions . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . endorser . as_slice () . len () ; offsets . push (total_size) ; total_size += self . created_at . as_slice () . len () ; offsets . push (total_size) ; total_size += self . starting_time . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ending_time . as_slice () . len () ; offsets . push (total_size) ; total_size += self . rules . as_slice () . len () ; offsets . push (total_size) ; total_size += self . metadata . as_slice () . len () ; offsets . push (total_size) ; total_size += self . status . as_slice () . len () ; offsets . push (total_size) ; total_size += self . quests . as_slice () . len () ; offsets . push (total_size) ; total_size += self . participants_count . as_slice () . len () ; offsets . push (total_size) ; total_size += self . total_completions . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . endorser . as_slice ()) ? ; writer . write_all (self . created_at . as_slice ()) ? ; writer . write_all (self . starting_time . as_slice ()) ? ; writer . write_all (self . ending_time . as_slice ()) ? ; writer . write_all (self . rules . as_slice ()) ? ; writer . write_all (self . metadata . as_slice ()) ? ; writer . write_all (self . status . as_slice ()) ? ; writer . write_all (self . quests . as_slice ()) ? ; writer . write_all (self . participants_count . as_slice ()) ? ; writer . write_all (self . total_completions . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CampaignData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct CampaignDataVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for CampaignDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for CampaignDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for CampaignDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for CampaignDataVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; CampaignDataVec :: new_unchecked (v) } } impl CampaignDataVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CampaignData > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CampaignData { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { CampaignData :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; CampaignData :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> CampaignDataVecReader < 'r > { CampaignDataVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for CampaignDataVec { type Builder = CampaignDataVecBuilder ; const NAME : & 'static str = "CampaignDataVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { CampaignDataVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignDataVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { CampaignDataVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct CampaignDataVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for CampaignDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for CampaignDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for CampaignDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > CampaignDataVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < CampaignDataReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> CampaignDataReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { CampaignDataReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; CampaignDataReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CampaignDataVecReader < 'r > { type Entity = CampaignDataVec ; const NAME : & 'static str = "CampaignDataVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { CampaignDataVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; CampaignDataReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct CampaignDataVecBuilder (pub (crate) Vec < CampaignData >) ; impl CampaignDataVecBuilder { pub fn set (mut self , v : Vec < CampaignData >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < CampaignData > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = CampaignData >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < CampaignData > where T : :: core :: convert :: Into < CampaignData > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for CampaignDataVecBuilder { type Entity = CampaignDataVec ; const NAME : & 'static str = "CampaignDataVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; CampaignDataVec :: new_unchecked (inner . into ()) } }
pub struct CampaignDataVecIterator (CampaignDataVec , usize , usize) ; impl :: core :: iter :: Iterator for CampaignDataVecIterator { type Item = CampaignData ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for CampaignDataVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for CampaignDataVec { type Item = CampaignData ; type IntoIter = CampaignDataVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; CampaignDataVecIterator (self , 0 , len) } } impl < 'r > CampaignDataVecReader < 'r > { pub fn iter < 't > (& 't self) -> CampaignDataVecReaderIterator < 't , 'r > { CampaignDataVecReaderIterator (& self , 0 , self . len ()) } } pub struct CampaignDataVecReaderIterator < 't , 'r > (& 't CampaignDataVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for CampaignDataVecReaderIterator < 't , 'r > { type Item = CampaignDataReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for CampaignDataVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < CampaignData > for CampaignDataVec { fn from_iter < T : IntoIterator < Item = CampaignData >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < CampaignData >> for CampaignDataVec { fn from (v : Vec < CampaignData >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct TippingProposalMetadata (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for TippingProposalMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for TippingProposalMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for TippingProposalMetadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "contribution_title" , self . contribution_title ()) ? ; write ! (f , ", {}: {}" , "contribution_type_tags" , self . contribution_type_tags ()) ? ; write ! (f , ", {}: {}" , "description" , self . description ()) ? ; write ! (f , ", {}: {}" , "proposal_creation_timestamp" , self . proposal_creation_timestamp ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for TippingProposalMetadata { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; TippingProposalMetadata :: new_unchecked (v) } } impl TippingProposalMetadata { const DEFAULT_VALUE : [u8 ; 40] = [40 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn contribution_title (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn contribution_type_tags (& self) -> StringVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; StringVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proposal_creation_timestamp (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint64 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> TippingProposalMetadataReader < 'r > { TippingProposalMetadataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for TippingProposalMetadata { type Builder = TippingProposalMetadataBuilder ; const NAME : & 'static str = "TippingProposalMetadata" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { TippingProposalMetadata (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalMetadataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalMetadataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . contribution_title (self . contribution_title ()) . contribution_type_tags (self . contribution_type_tags ()) . description (self . description ()) . proposal_creation_timestamp (self . proposal_creation_timestamp ()) } }
# [derive (Clone , Copy)] pub struct TippingProposalMetadataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TippingProposalMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TippingProposalMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TippingProposalMetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "contribution_title" , self . contribution_title ()) ? ; write ! (f , ", {}: {}" , "contribution_type_tags" , self . contribution_type_tags ()) ? ; write ! (f , ", {}: {}" , "description" , self . description ()) ? ; write ! (f , ", {}: {}" , "proposal_creation_timestamp" , self . proposal_creation_timestamp ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > TippingProposalMetadataReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn contribution_title (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn contribution_type_tags (& self) -> StringVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; StringVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proposal_creation_timestamp (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint64Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TippingProposalMetadataReader < 'r > { type Entity = TippingProposalMetadata ; const NAME : & 'static str = "TippingProposalMetadataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TippingProposalMetadataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } StringReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; StringVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; StringReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TippingProposalMetadataBuilder { pub (crate) contribution_title : String , pub (crate) contribution_type_tags : StringVec , pub (crate) description : String , pub (crate) proposal_creation_timestamp : Uint64 , } impl TippingProposalMetadataBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn contribution_title < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . contribution_title = v . into () ; self } pub fn contribution_type_tags < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < StringVec > { self . contribution_type_tags = v . into () ; self } pub fn description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . description = v . into () ; self } pub fn proposal_creation_timestamp < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . proposal_creation_timestamp = v . into () ; self } } impl molecule :: prelude :: Builder for TippingProposalMetadataBuilder { type Entity = TippingProposalMetadata ; const NAME : & 'static str = "TippingProposalMetadataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . contribution_title . as_slice () . len () + self . contribution_type_tags . as_slice () . len () + self . description . as_slice () . len () + self . proposal_creation_timestamp . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . contribution_title . as_slice () . len () ; offsets . push (total_size) ; total_size += self . contribution_type_tags . as_slice () . len () ; offsets . push (total_size) ; total_size += self . description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proposal_creation_timestamp . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . contribution_title . as_slice ()) ? ; writer . write_all (self . contribution_type_tags . as_slice ()) ? ; writer . write_all (self . description . as_slice ()) ? ; writer . write_all (self . proposal_creation_timestamp . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; TippingProposalMetadata :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct TippingProposalData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for TippingProposalData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for TippingProposalData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for TippingProposalData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "target_address" , self . target_address ()) ? ; write ! (f , ", {}: {}" , "proposer_lock_hash" , self . proposer_lock_hash ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "amount" , self . amount ()) ? ; write ! (f , ", {}: {}" , "tipping_transaction_hash" , self . tipping_transaction_hash ()) ? ; write ! (f , ", {}: {}" , "approval_transaction_hash" , self . approval_transaction_hash ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for TippingProposalData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; TippingProposalData :: new_unchecked (v) } } impl TippingProposalData { const DEFAULT_VALUE : [u8 ; 116] = [116 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 104 , 0 , 0 , 0 , 112 , 0 , 0 , 0 , 112 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 40 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn target_address (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn proposer_lock_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn metadata (& self) -> TippingProposalMetadata { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TippingProposalMetadata :: new_unchecked (self . 0 . slice (start .. end)) } pub fn amount (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn tipping_transaction_hash (& self) -> Byte32Opt { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte32Opt :: new_unchecked (self . 0 . slice (start .. end)) } pub fn approval_transaction_hash (& self) -> Byte32Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte32Vec :: new_unchecked (self . 0 . slice (start .. end)) } else { Byte32Vec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> TippingProposalDataReader < 'r > { TippingProposalDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for TippingProposalData { type Builder = TippingProposalDataBuilder ; const NAME : & 'static str = "TippingProposalData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { TippingProposalData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . target_address (self . target_address ()) . proposer_lock_hash (self . proposer_lock_hash ()) . metadata (self . metadata ()) . amount (self . amount ()) . tipping_transaction_hash (self . tipping_transaction_hash ()) . approval_transaction_hash (self . approval_transaction_hash ()) } }
# [derive (Clone , Copy)] pub struct TippingProposalDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TippingProposalDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TippingProposalDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TippingProposalDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "target_address" , self . target_address ()) ? ; write ! (f , ", {}: {}" , "proposer_lock_hash" , self . proposer_lock_hash ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "amount" , self . amount ()) ? ; write ! (f , ", {}: {}" , "tipping_transaction_hash" , self . tipping_transaction_hash ()) ? ; write ! (f , ", {}: {}" , "approval_transaction_hash" , self . approval_transaction_hash ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > TippingProposalDataReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn target_address (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn proposer_lock_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn metadata (& self) -> TippingProposalMetadataReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TippingProposalMetadataReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn amount (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn tipping_transaction_hash (& self) -> Byte32OptReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte32OptReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn approval_transaction_hash (& self) -> Byte32VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte32VecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { Byte32VecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TippingProposalDataReader < 'r > { type Entity = TippingProposalData ; const NAME : & 'static str = "TippingProposalDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TippingProposalDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } StringReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; TippingProposalMetadataReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Byte32OptReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Byte32VecReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TippingProposalDataBuilder { pub (crate) target_address : String , pub (crate) proposer_lock_hash : Byte32 , pub (crate) metadata : TippingProposalMetadata , pub (crate) amount : Uint64 , pub (crate) tipping_transaction_hash : Byte32Opt , pub (crate) approval_transaction_hash : Byte32Vec , } impl TippingProposalDataBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn target_address < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . target_address = v . into () ; self } pub fn proposer_lock_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . proposer_lock_hash = v . into () ; self } pub fn metadata < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TippingProposalMetadata > { self . metadata = v . into () ; self } pub fn amount < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . amount = v . into () ; self } pub fn tipping_transaction_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Opt > { self . tipping_transaction_hash = v . into () ; self } pub fn approval_transaction_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Vec > { self . approval_transaction_hash = v . into () ; self } } impl molecule :: prelude :: Builder for TippingProposalDataBuilder { type Entity = TippingProposalData ; const NAME : & 'static str = "TippingProposalDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . target_address . as_slice () . len () + self . proposer_lock_hash . as_slice () . len () + self . metadata . as_slice () . len () + self . amount . as_slice () . len () + self . tipping_transaction_hash . as_slice () . len () + self . approval_transaction_hash . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . target_address . as_slice () . len () ; offsets . push (total_size) ; total_size += self . proposer_lock_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . metadata . as_slice () . len () ; offsets . push (total_size) ; total_size += self . amount . as_slice () . len () ; offsets . push (total_size) ; total_size += self . tipping_transaction_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . approval_transaction_hash . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . target_address . as_slice ()) ? ; writer . write_all (self . proposer_lock_hash . as_slice ()) ? ; writer . write_all (self . metadata . as_slice ()) ? ; writer . write_all (self . amount . as_slice ()) ? ; writer . write_all (self . tipping_transaction_hash . as_slice ()) ? ; writer . write_all (self . approval_transaction_hash . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; TippingProposalData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct TippingProposalDataVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for TippingProposalDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for TippingProposalDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for TippingProposalDataVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for TippingProposalDataVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; TippingProposalDataVec :: new_unchecked (v) } } impl TippingProposalDataVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < TippingProposalData > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> TippingProposalData { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { TippingProposalData :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; TippingProposalData :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> TippingProposalDataVecReader < 'r > { TippingProposalDataVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for TippingProposalDataVec { type Builder = TippingProposalDataVecBuilder ; const NAME : & 'static str = "TippingProposalDataVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { TippingProposalDataVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalDataVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingProposalDataVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct TippingProposalDataVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TippingProposalDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TippingProposalDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TippingProposalDataVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > TippingProposalDataVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < TippingProposalDataReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> TippingProposalDataReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { TippingProposalDataReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; TippingProposalDataReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TippingProposalDataVecReader < 'r > { type Entity = TippingProposalDataVec ; const NAME : & 'static str = "TippingProposalDataVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TippingProposalDataVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; TippingProposalDataReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TippingProposalDataVecBuilder (pub (crate) Vec < TippingProposalData >) ; impl TippingProposalDataVecBuilder { pub fn set (mut self , v : Vec < TippingProposalData >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TippingProposalData > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = TippingProposalData >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < TippingProposalData > where T : :: core :: convert :: Into < TippingProposalData > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for TippingProposalDataVecBuilder { type Entity = TippingProposalDataVec ; const NAME : & 'static str = "TippingProposalDataVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; TippingProposalDataVec :: new_unchecked (inner . into ()) } }
pub struct TippingProposalDataVecIterator (TippingProposalDataVec , usize , usize) ; impl :: core :: iter :: Iterator for TippingProposalDataVecIterator { type Item = TippingProposalData ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for TippingProposalDataVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for TippingProposalDataVec { type Item = TippingProposalData ; type IntoIter = TippingProposalDataVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; TippingProposalDataVecIterator (self , 0 , len) } } impl < 'r > TippingProposalDataVecReader < 'r > { pub fn iter < 't > (& 't self) -> TippingProposalDataVecReaderIterator < 't , 'r > { TippingProposalDataVecReaderIterator (& self , 0 , self . len ()) } } pub struct TippingProposalDataVecReaderIterator < 't , 'r > (& 't TippingProposalDataVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for TippingProposalDataVecReaderIterator < 't , 'r > { type Item = TippingProposalDataReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for TippingProposalDataVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < TippingProposalData > for TippingProposalDataVec { fn from_iter < T : IntoIterator < Item = TippingProposalData >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < TippingProposalData >> for TippingProposalDataVec { fn from (v : Vec < TippingProposalData >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct EndorserInfo (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for EndorserInfo { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for EndorserInfo { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for EndorserInfo { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "endorser_lock_hash" , self . endorser_lock_hash ()) ? ; write ! (f , ", {}: {}" , "endorser_name" , self . endorser_name ()) ? ; write ! (f , ", {}: {}" , "endorser_description" , self . endorser_description ()) ? ; write ! (f , ", {}: {}" , "website" , self . website ()) ? ; write ! (f , ", {}: {}" , "social_links" , self . social_links ()) ? ; write ! (f , ", {}: {}" , "verified" , self . verified ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for EndorserInfo { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; EndorserInfo :: new_unchecked (v) } } impl EndorserInfo { const DEFAULT_VALUE : [u8 ; 77] = [77 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 68 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 76 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn endorser_lock_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn endorser_name (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn endorser_description (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn website (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } pub fn social_links (& self) -> StringVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; StringVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn verified (& self) -> Uint8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint8 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> EndorserInfoReader < 'r > { EndorserInfoReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for EndorserInfo { type Builder = EndorserInfoBuilder ; const NAME : & 'static str = "EndorserInfo" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { EndorserInfo (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { EndorserInfoReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { EndorserInfoReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . endorser_lock_hash (self . endorser_lock_hash ()) . endorser_name (self . endorser_name ()) . endorser_description (self . endorser_description ()) . website (self . website ()) . social_links (self . social_links ()) . verified (self . verified ()) } }
# [derive (Clone , Copy)] pub struct EndorserInfoReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for EndorserInfoReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for EndorserInfoReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for EndorserInfoReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "endorser_lock_hash" , self . endorser_lock_hash ()) ? ; write ! (f , ", {}: {}" , "endorser_name" , self . endorser_name ()) ? ; write ! (f , ", {}: {}" , "endorser_description" , self . endorser_description ()) ? ; write ! (f , ", {}: {}" , "website" , self . website ()) ? ; write ! (f , ", {}: {}" , "social_links" , self . social_links ()) ? ; write ! (f , ", {}: {}" , "verified" , self . verified ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > EndorserInfoReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn endorser_lock_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn endorser_name (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn endorser_description (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn website (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn social_links (& self) -> StringVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; StringVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn verified (& self) -> Uint8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint8Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for EndorserInfoReader < 'r > { type Entity = EndorserInfo ; const NAME : & 'static str = "EndorserInfoReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { EndorserInfoReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; StringReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; StringReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; StringReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; StringVecReader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Uint8Reader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct EndorserInfoBuilder { pub (crate) endorser_lock_hash : Byte32 , pub (crate) endorser_name : String , pub (crate) endorser_description : String , pub (crate) website : String , pub (crate) social_links : StringVec , pub (crate) verified : Uint8 , } impl EndorserInfoBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn endorser_lock_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . endorser_lock_hash = v . into () ; self } pub fn endorser_name < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . endorser_name = v . into () ; self } pub fn endorser_description < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . endorser_description = v . into () ; self } pub fn website < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . website = v . into () ; self } pub fn social_links < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < StringVec > { self . social_links = v . into () ; self } pub fn verified < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint8 > { self . verified = v . into () ; self } } impl molecule :: prelude :: Builder for EndorserInfoBuilder { type Entity = EndorserInfo ; const NAME : & 'static str = "EndorserInfoBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . endorser_lock_hash . as_slice () . len () + self . endorser_name . as_slice () . len () + self . endorser_description . as_slice () . len () + self . website . as_slice () . len () + self . social_links . as_slice () . len () + self . verified . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . endorser_lock_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . endorser_name . as_slice () . len () ; offsets . push (total_size) ; total_size += self . endorser_description . as_slice () . len () ; offsets . push (total_size) ; total_size += self . website . as_slice () . len () ; offsets . push (total_size) ; total_size += self . social_links . as_slice () . len () ; offsets . push (total_size) ; total_size += self . verified . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . endorser_lock_hash . as_slice ()) ? ; writer . write_all (self . endorser_name . as_slice ()) ? ; writer . write_all (self . endorser_description . as_slice ()) ? ; writer . write_all (self . website . as_slice ()) ? ; writer . write_all (self . social_links . as_slice ()) ? ; writer . write_all (self . verified . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; EndorserInfo :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct EndorserInfoVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for EndorserInfoVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for EndorserInfoVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for EndorserInfoVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for EndorserInfoVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; EndorserInfoVec :: new_unchecked (v) } } impl EndorserInfoVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < EndorserInfo > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> EndorserInfo { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { EndorserInfo :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; EndorserInfo :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> EndorserInfoVecReader < 'r > { EndorserInfoVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for EndorserInfoVec { type Builder = EndorserInfoVecBuilder ; const NAME : & 'static str = "EndorserInfoVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { EndorserInfoVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { EndorserInfoVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { EndorserInfoVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct EndorserInfoVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for EndorserInfoVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for EndorserInfoVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for EndorserInfoVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > EndorserInfoVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < EndorserInfoReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> EndorserInfoReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { EndorserInfoReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; EndorserInfoReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for EndorserInfoVecReader < 'r > { type Entity = EndorserInfoVec ; const NAME : & 'static str = "EndorserInfoVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { EndorserInfoVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; EndorserInfoReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct EndorserInfoVecBuilder (pub (crate) Vec < EndorserInfo >) ; impl EndorserInfoVecBuilder { pub fn set (mut self , v : Vec < EndorserInfo >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < EndorserInfo > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = EndorserInfo >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < EndorserInfo > where T : :: core :: convert :: Into < EndorserInfo > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for EndorserInfoVecBuilder { type Entity = EndorserInfoVec ; const NAME : & 'static str = "EndorserInfoVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; EndorserInfoVec :: new_unchecked (inner . into ()) } }
pub struct EndorserInfoVecIterator (EndorserInfoVec , usize , usize) ; impl :: core :: iter :: Iterator for EndorserInfoVecIterator { type Item = EndorserInfo ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for EndorserInfoVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for EndorserInfoVec { type Item = EndorserInfo ; type IntoIter = EndorserInfoVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; EndorserInfoVecIterator (self , 0 , len) } } impl < 'r > EndorserInfoVecReader < 'r > { pub fn iter < 't > (& 't self) -> EndorserInfoVecReaderIterator < 't , 'r > { EndorserInfoVecReaderIterator (& self , 0 , self . len ()) } } pub struct EndorserInfoVecReaderIterator < 't , 'r > (& 't EndorserInfoVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for EndorserInfoVecReaderIterator < 't , 'r > { type Item = EndorserInfoReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for EndorserInfoVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < EndorserInfo > for EndorserInfoVec { fn from_iter < T : IntoIterator < Item = EndorserInfo >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < EndorserInfo >> for EndorserInfoVec { fn from (v : Vec < EndorserInfo >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct TippingConfig (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for TippingConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for TippingConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for TippingConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "approval_requirement_thresholds" , self . approval_requirement_thresholds ()) ? ; write ! (f , ", {}: {}" , "expiration_duration" , self . expiration_duration ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for TippingConfig { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; TippingConfig :: new_unchecked (v) } } impl TippingConfig { const DEFAULT_VALUE : [u8 ; 24] = [24 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn approval_requirement_thresholds (& self) -> Uint128Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint128Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn expiration_duration (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } else { Uint64 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> TippingConfigReader < 'r > { TippingConfigReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for TippingConfig { type Builder = TippingConfigBuilder ; const NAME : & 'static str = "TippingConfig" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { TippingConfig (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingConfigReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { TippingConfigReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . approval_requirement_thresholds (self . approval_requirement_thresholds ()) . expiration_duration (self . expiration_duration ()) } }
# [derive (Clone , Copy)] pub struct TippingConfigReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for TippingConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for TippingConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for TippingConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "approval_requirement_thresholds" , self . approval_requirement_thresholds ()) ? ; write ! (f , ", {}: {}" , "expiration_duration" , self . expiration_duration ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > TippingConfigReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn approval_requirement_thresholds (& self) -> Uint128VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint128VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn expiration_duration (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Uint64Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for TippingConfigReader < 'r > { type Entity = TippingConfig ; const NAME : & 'static str = "TippingConfigReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { TippingConfigReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint128VecReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct TippingConfigBuilder { pub (crate) approval_requirement_thresholds : Uint128Vec , pub (crate) expiration_duration : Uint64 , } impl TippingConfigBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn approval_requirement_thresholds < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint128Vec > { self . approval_requirement_thresholds = v . into () ; self } pub fn expiration_duration < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . expiration_duration = v . into () ; self } } impl molecule :: prelude :: Builder for TippingConfigBuilder { type Entity = TippingConfig ; const NAME : & 'static str = "TippingConfigBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . approval_requirement_thresholds . as_slice () . len () + self . expiration_duration . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . approval_requirement_thresholds . as_slice () . len () ; offsets . push (total_size) ; total_size += self . expiration_duration . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . approval_requirement_thresholds . as_slice ()) ? ; writer . write_all (self . expiration_duration . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; TippingConfig :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct ScriptCodeHashes (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ScriptCodeHashes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ScriptCodeHashes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ScriptCodeHashes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "ckb_boost_protocol_type_code_hash" , self . ckb_boost_protocol_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_protocol_lock_code_hash" , self . ckb_boost_protocol_lock_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_campaign_type_code_hash" , self . ckb_boost_campaign_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_campaign_lock_code_hash" , self . ckb_boost_campaign_lock_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_user_type_code_hash" , self . ckb_boost_user_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "accepted_udt_type_scripts" , self . accepted_udt_type_scripts ()) ? ; write ! (f , ", {}: {}" , "accepted_dob_type_scripts" , self . accepted_dob_type_scripts ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ScriptCodeHashes { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ScriptCodeHashes :: new_unchecked (v) } } impl ScriptCodeHashes { const DEFAULT_VALUE : [u8 ; 200] = [200 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 96 , 0 , 0 , 0 , 128 , 0 , 0 , 0 , 160 , 0 , 0 , 0 , 192 , 0 , 0 , 0 , 196 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 7 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn ckb_boost_protocol_type_code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ckb_boost_protocol_lock_code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ckb_boost_campaign_type_code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ckb_boost_campaign_lock_code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn ckb_boost_user_type_code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn accepted_udt_type_scripts (& self) -> ScriptVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; ScriptVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn accepted_dob_type_scripts (& self) -> ScriptVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [32 ..]) as usize ; ScriptVec :: new_unchecked (self . 0 . slice (start .. end)) } else { ScriptVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ScriptCodeHashesReader < 'r > { ScriptCodeHashesReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ScriptCodeHashes { type Builder = ScriptCodeHashesBuilder ; const NAME : & 'static str = "ScriptCodeHashes" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ScriptCodeHashes (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptCodeHashesReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptCodeHashesReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . ckb_boost_protocol_type_code_hash (self . ckb_boost_protocol_type_code_hash ()) . ckb_boost_protocol_lock_code_hash (self . ckb_boost_protocol_lock_code_hash ()) . ckb_boost_campaign_type_code_hash (self . ckb_boost_campaign_type_code_hash ()) . ckb_boost_campaign_lock_code_hash (self . ckb_boost_campaign_lock_code_hash ()) . ckb_boost_user_type_code_hash (self . ckb_boost_user_type_code_hash ()) . accepted_udt_type_scripts (self . accepted_udt_type_scripts ()) . accepted_dob_type_scripts (self . accepted_dob_type_scripts ()) } }
# [derive (Clone , Copy)] pub struct ScriptCodeHashesReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptCodeHashesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptCodeHashesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptCodeHashesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "ckb_boost_protocol_type_code_hash" , self . ckb_boost_protocol_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_protocol_lock_code_hash" , self . ckb_boost_protocol_lock_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_campaign_type_code_hash" , self . ckb_boost_campaign_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_campaign_lock_code_hash" , self . ckb_boost_campaign_lock_code_hash ()) ? ; write ! (f , ", {}: {}" , "ckb_boost_user_type_code_hash" , self . ckb_boost_user_type_code_hash ()) ? ; write ! (f , ", {}: {}" , "accepted_udt_type_scripts" , self . accepted_udt_type_scripts ()) ? ; write ! (f , ", {}: {}" , "accepted_dob_type_scripts" , self . accepted_dob_type_scripts ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ScriptCodeHashesReader < 'r > { pub const FIELD_COUNT : usize = 7 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn ckb_boost_protocol_type_code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ckb_boost_protocol_lock_code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ckb_boost_campaign_type_code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ckb_boost_campaign_lock_code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn ckb_boost_user_type_code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn accepted_udt_type_scripts (& self) -> ScriptVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; ScriptVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn accepted_dob_type_scripts (& self) -> ScriptVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [32 ..]) as usize ; ScriptVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ScriptVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptCodeHashesReader < 'r > { type Entity = ScriptCodeHashes ; const NAME : & 'static str = "ScriptCodeHashesReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptCodeHashesReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; ScriptVecReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; ScriptVecReader :: verify (& slice [offsets [6] .. offsets [7]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptCodeHashesBuilder { pub (crate) ckb_boost_protocol_type_code_hash : Byte32 , pub (crate) ckb_boost_protocol_lock_code_hash : Byte32 , pub (crate) ckb_boost_campaign_type_code_hash : Byte32 , pub (crate) ckb_boost_campaign_lock_code_hash : Byte32 , pub (crate) ckb_boost_user_type_code_hash : Byte32 , pub (crate) accepted_udt_type_scripts : ScriptVec , pub (crate) accepted_dob_type_scripts : ScriptVec , } impl ScriptCodeHashesBuilder { pub const FIELD_COUNT : usize = 7 ; pub fn ckb_boost_protocol_type_code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . ckb_boost_protocol_type_code_hash = v . into () ; self } pub fn ckb_boost_protocol_lock_code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . ckb_boost_protocol_lock_code_hash = v . into () ; self } pub fn ckb_boost_campaign_type_code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . ckb_boost_campaign_type_code_hash = v . into () ; self } pub fn ckb_boost_campaign_lock_code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . ckb_boost_campaign_lock_code_hash = v . into () ; self } pub fn ckb_boost_user_type_code_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . ckb_boost_user_type_code_hash = v . into () ; self } pub fn accepted_udt_type_scripts < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ScriptVec > { self . accepted_udt_type_scripts = v . into () ; self } pub fn accepted_dob_type_scripts < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ScriptVec > { self . accepted_dob_type_scripts = v . into () ; self } } impl molecule :: prelude :: Builder for ScriptCodeHashesBuilder { type Entity = ScriptCodeHashes ; const NAME : & 'static str = "ScriptCodeHashesBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . ckb_boost_protocol_type_code_hash . as_slice () . len () + self . ckb_boost_protocol_lock_code_hash . as_slice () . len () + self . ckb_boost_campaign_type_code_hash . as_slice () . len () + self . ckb_boost_campaign_lock_code_hash . as_slice () . len () + self . ckb_boost_user_type_code_hash . as_slice () . len () + self . accepted_udt_type_scripts . as_slice () . len () + self . accepted_dob_type_scripts . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . ckb_boost_protocol_type_code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ckb_boost_protocol_lock_code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ckb_boost_campaign_type_code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ckb_boost_campaign_lock_code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . ckb_boost_user_type_code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . accepted_udt_type_scripts . as_slice () . len () ; offsets . push (total_size) ; total_size += self . accepted_dob_type_scripts . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . ckb_boost_protocol_type_code_hash . as_slice ()) ? ; writer . write_all (self . ckb_boost_protocol_lock_code_hash . as_slice ()) ? ; writer . write_all (self . ckb_boost_campaign_type_code_hash . as_slice ()) ? ; writer . write_all (self . ckb_boost_campaign_lock_code_hash . as_slice ()) ? ; writer . write_all (self . ckb_boost_user_type_code_hash . as_slice ()) ? ; writer . write_all (self . accepted_udt_type_scripts . as_slice ()) ? ; writer . write_all (self . accepted_dob_type_scripts . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ScriptCodeHashes :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct ProtocolConfig (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ProtocolConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ProtocolConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ProtocolConfig { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "admin_lock_hash_vec" , self . admin_lock_hash_vec ()) ? ; write ! (f , ", {}: {}" , "script_code_hashes" , self . script_code_hashes ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ProtocolConfig { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ProtocolConfig :: new_unchecked (v) } } impl ProtocolConfig { const DEFAULT_VALUE : [u8 ; 216] = [216 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 200 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 96 , 0 , 0 , 0 , 128 , 0 , 0 , 0 , 160 , 0 , 0 , 0 , 192 , 0 , 0 , 0 , 196 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn admin_lock_hash_vec (& self) -> Byte32Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn script_code_hashes (& self) -> ScriptCodeHashes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ScriptCodeHashes :: new_unchecked (self . 0 . slice (start .. end)) } else { ScriptCodeHashes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ProtocolConfigReader < 'r > { ProtocolConfigReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ProtocolConfig { type Builder = ProtocolConfigBuilder ; const NAME : & 'static str = "ProtocolConfig" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ProtocolConfig (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProtocolConfigReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProtocolConfigReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . admin_lock_hash_vec (self . admin_lock_hash_vec ()) . script_code_hashes (self . script_code_hashes ()) } }
# [derive (Clone , Copy)] pub struct ProtocolConfigReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ProtocolConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ProtocolConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ProtocolConfigReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "admin_lock_hash_vec" , self . admin_lock_hash_vec ()) ? ; write ! (f , ", {}: {}" , "script_code_hashes" , self . script_code_hashes ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ProtocolConfigReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn admin_lock_hash_vec (& self) -> Byte32VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn script_code_hashes (& self) -> ScriptCodeHashesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ScriptCodeHashesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ScriptCodeHashesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ProtocolConfigReader < 'r > { type Entity = ProtocolConfig ; const NAME : & 'static str = "ProtocolConfigReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ProtocolConfigReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32VecReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; ScriptCodeHashesReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ProtocolConfigBuilder { pub (crate) admin_lock_hash_vec : Byte32Vec , pub (crate) script_code_hashes : ScriptCodeHashes , } impl ProtocolConfigBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn admin_lock_hash_vec < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Vec > { self . admin_lock_hash_vec = v . into () ; self } pub fn script_code_hashes < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ScriptCodeHashes > { self . script_code_hashes = v . into () ; self } } impl molecule :: prelude :: Builder for ProtocolConfigBuilder { type Entity = ProtocolConfig ; const NAME : & 'static str = "ProtocolConfigBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . admin_lock_hash_vec . as_slice () . len () + self . script_code_hashes . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . admin_lock_hash_vec . as_slice () . len () ; offsets . push (total_size) ; total_size += self . script_code_hashes . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . admin_lock_hash_vec . as_slice ()) ? ; writer . write_all (self . script_code_hashes . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ProtocolConfig :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct ProtocolData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ProtocolData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ProtocolData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ProtocolData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "campaigns_approved" , self . campaigns_approved ()) ? ; write ! (f , ", {}: {}" , "tipping_proposals" , self . tipping_proposals ()) ? ; write ! (f , ", {}: {}" , "tipping_config" , self . tipping_config ()) ? ; write ! (f , ", {}: {}" , "endorsers_whitelist" , self . endorsers_whitelist ()) ? ; write ! (f , ", {}: {}" , "last_updated" , self . last_updated ()) ? ; write ! (f , ", {}: {}" , "protocol_config" , self . protocol_config ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ProtocolData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ProtocolData :: new_unchecked (v) } } impl ProtocolData { const DEFAULT_VALUE : [u8 ; 288] = [32 , 1 , 0 , 0 , 28 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 36 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 216 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 200 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 96 , 0 , 0 , 0 , 128 , 0 , 0 , 0 , 160 , 0 , 0 , 0 , 192 , 0 , 0 , 0 , 196 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn campaigns_approved (& self) -> Byte32Vec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Vec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn tipping_proposals (& self) -> TippingProposalDataVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; TippingProposalDataVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn tipping_config (& self) -> TippingConfig { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TippingConfig :: new_unchecked (self . 0 . slice (start .. end)) } pub fn endorsers_whitelist (& self) -> EndorserInfoVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; EndorserInfoVec :: new_unchecked (self . 0 . slice (start .. end)) } pub fn last_updated (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn protocol_config (& self) -> ProtocolConfig { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; ProtocolConfig :: new_unchecked (self . 0 . slice (start .. end)) } else { ProtocolConfig :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ProtocolDataReader < 'r > { ProtocolDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ProtocolData { type Builder = ProtocolDataBuilder ; const NAME : & 'static str = "ProtocolData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ProtocolData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProtocolDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ProtocolDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . campaigns_approved (self . campaigns_approved ()) . tipping_proposals (self . tipping_proposals ()) . tipping_config (self . tipping_config ()) . endorsers_whitelist (self . endorsers_whitelist ()) . last_updated (self . last_updated ()) . protocol_config (self . protocol_config ()) } }
# [derive (Clone , Copy)] pub struct ProtocolDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ProtocolDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ProtocolDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ProtocolDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "campaigns_approved" , self . campaigns_approved ()) ? ; write ! (f , ", {}: {}" , "tipping_proposals" , self . tipping_proposals ()) ? ; write ! (f , ", {}: {}" , "tipping_config" , self . tipping_config ()) ? ; write ! (f , ", {}: {}" , "endorsers_whitelist" , self . endorsers_whitelist ()) ? ; write ! (f , ", {}: {}" , "last_updated" , self . last_updated ()) ? ; write ! (f , ", {}: {}" , "protocol_config" , self . protocol_config ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ProtocolDataReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn campaigns_approved (& self) -> Byte32VecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32VecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn tipping_proposals (& self) -> TippingProposalDataVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; TippingProposalDataVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn tipping_config (& self) -> TippingConfigReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; TippingConfigReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn endorsers_whitelist (& self) -> EndorserInfoVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; EndorserInfoVecReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn last_updated (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn protocol_config (& self) -> ProtocolConfigReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; ProtocolConfigReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ProtocolConfigReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ProtocolDataReader < 'r > { type Entity = ProtocolData ; const NAME : & 'static str = "ProtocolDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ProtocolDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32VecReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; TippingProposalDataVecReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; TippingConfigReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; EndorserInfoVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; ProtocolConfigReader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ProtocolDataBuilder { pub (crate) campaigns_approved : Byte32Vec , pub (crate) tipping_proposals : TippingProposalDataVec , pub (crate) tipping_config : TippingConfig , pub (crate) endorsers_whitelist : EndorserInfoVec , pub (crate) last_updated : Uint64 , pub (crate) protocol_config : ProtocolConfig , } impl ProtocolDataBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn campaigns_approved < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32Vec > { self . campaigns_approved = v . into () ; self } pub fn tipping_proposals < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TippingProposalDataVec > { self . tipping_proposals = v . into () ; self } pub fn tipping_config < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < TippingConfig > { self . tipping_config = v . into () ; self } pub fn endorsers_whitelist < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < EndorserInfoVec > { self . endorsers_whitelist = v . into () ; self } pub fn last_updated < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . last_updated = v . into () ; self } pub fn protocol_config < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < ProtocolConfig > { self . protocol_config = v . into () ; self } } impl molecule :: prelude :: Builder for ProtocolDataBuilder { type Entity = ProtocolData ; const NAME : & 'static str = "ProtocolDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . campaigns_approved . as_slice () . len () + self . tipping_proposals . as_slice () . len () + self . tipping_config . as_slice () . len () + self . endorsers_whitelist . as_slice () . len () + self . last_updated . as_slice () . len () + self . protocol_config . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . campaigns_approved . as_slice () . len () ; offsets . push (total_size) ; total_size += self . tipping_proposals . as_slice () . len () ; offsets . push (total_size) ; total_size += self . tipping_config . as_slice () . len () ; offsets . push (total_size) ; total_size += self . endorsers_whitelist . as_slice () . len () ; offsets . push (total_size) ; total_size += self . last_updated . as_slice () . len () ; offsets . push (total_size) ; total_size += self . protocol_config . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . campaigns_approved . as_slice ()) ? ; writer . write_all (self . tipping_proposals . as_slice ()) ? ; writer . write_all (self . tipping_config . as_slice ()) ? ; writer . write_all (self . endorsers_whitelist . as_slice ()) ? ; writer . write_all (self . last_updated . as_slice ()) ? ; writer . write_all (self . protocol_config . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ProtocolData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct UserVerificationData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UserVerificationData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UserVerificationData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UserVerificationData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "telegram_personal_chat_id" , self . telegram_personal_chat_id ()) ? ; write ! (f , ", {}: {}" , "identity_verification_data" , self . identity_verification_data ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for UserVerificationData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UserVerificationData :: new_unchecked (v) } } impl UserVerificationData { const DEFAULT_VALUE : [u8 ; 32] = [32 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn telegram_personal_chat_id (& self) -> Uint128 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint128 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn identity_verification_data (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> UserVerificationDataReader < 'r > { UserVerificationDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UserVerificationData { type Builder = UserVerificationDataBuilder ; const NAME : & 'static str = "UserVerificationData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UserVerificationData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserVerificationDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserVerificationDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . telegram_personal_chat_id (self . telegram_personal_chat_id ()) . identity_verification_data (self . identity_verification_data ()) } }
# [derive (Clone , Copy)] pub struct UserVerificationDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UserVerificationDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UserVerificationDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UserVerificationDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "telegram_personal_chat_id" , self . telegram_personal_chat_id ()) ? ; write ! (f , ", {}: {}" , "identity_verification_data" , self . identity_verification_data ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > UserVerificationDataReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn telegram_personal_chat_id (& self) -> Uint128Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Uint128Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn identity_verification_data (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UserVerificationDataReader < 'r > { type Entity = UserVerificationData ; const NAME : & 'static str = "UserVerificationDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UserVerificationDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Uint128Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UserVerificationDataBuilder { pub (crate) telegram_personal_chat_id : Uint128 , pub (crate) identity_verification_data : Bytes , } impl UserVerificationDataBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn telegram_personal_chat_id < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint128 > { self . telegram_personal_chat_id = v . into () ; self } pub fn identity_verification_data < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Bytes > { self . identity_verification_data = v . into () ; self } } impl molecule :: prelude :: Builder for UserVerificationDataBuilder { type Entity = UserVerificationData ; const NAME : & 'static str = "UserVerificationDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . telegram_personal_chat_id . as_slice () . len () + self . identity_verification_data . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . telegram_personal_chat_id . as_slice () . len () ; offsets . push (total_size) ; total_size += self . identity_verification_data . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . telegram_personal_chat_id . as_slice ()) ? ; writer . write_all (self . identity_verification_data . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UserVerificationData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct UserSubmissionRecord (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UserSubmissionRecord { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UserSubmissionRecord { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UserSubmissionRecord { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "campaign_type_hash" , self . campaign_type_hash ()) ? ; write ! (f , ", {}: {}" , "quest_id" , self . quest_id ()) ? ; write ! (f , ", {}: {}" , "submission_timestamp" , self . submission_timestamp ()) ? ; write ! (f , ", {}: {}" , "submission_content" , self . submission_content ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for UserSubmissionRecord { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UserSubmissionRecord :: new_unchecked (v) } } impl UserSubmissionRecord { const DEFAULT_VALUE : [u8 ; 68] = [68 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 52 , 0 , 0 , 0 , 56 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn campaign_type_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn quest_id (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn submission_timestamp (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn submission_content (& self) -> String { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; String :: new_unchecked (self . 0 . slice (start .. end)) } else { String :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> UserSubmissionRecordReader < 'r > { UserSubmissionRecordReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UserSubmissionRecord { type Builder = UserSubmissionRecordBuilder ; const NAME : & 'static str = "UserSubmissionRecord" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UserSubmissionRecord (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserSubmissionRecordReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserSubmissionRecordReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . campaign_type_hash (self . campaign_type_hash ()) . quest_id (self . quest_id ()) . submission_timestamp (self . submission_timestamp ()) . submission_content (self . submission_content ()) } }
# [derive (Clone , Copy)] pub struct UserSubmissionRecordReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UserSubmissionRecordReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UserSubmissionRecordReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UserSubmissionRecordReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "campaign_type_hash" , self . campaign_type_hash ()) ? ; write ! (f , ", {}: {}" , "quest_id" , self . quest_id ()) ? ; write ! (f , ", {}: {}" , "submission_timestamp" , self . submission_timestamp ()) ? ; write ! (f , ", {}: {}" , "submission_content" , self . submission_content ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > UserSubmissionRecordReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn campaign_type_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn quest_id (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn submission_timestamp (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn submission_content (& self) -> StringReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; StringReader :: new_unchecked (& self . as_slice () [start .. end]) } else { StringReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UserSubmissionRecordReader < 'r > { type Entity = UserSubmissionRecord ; const NAME : & 'static str = "UserSubmissionRecordReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UserSubmissionRecordReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; StringReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UserSubmissionRecordBuilder { pub (crate) campaign_type_hash : Byte32 , pub (crate) quest_id : Uint32 , pub (crate) submission_timestamp : Uint64 , pub (crate) submission_content : String , } impl UserSubmissionRecordBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn campaign_type_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . campaign_type_hash = v . into () ; self } pub fn quest_id < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . quest_id = v . into () ; self } pub fn submission_timestamp < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . submission_timestamp = v . into () ; self } pub fn submission_content < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < String > { self . submission_content = v . into () ; self } } impl molecule :: prelude :: Builder for UserSubmissionRecordBuilder { type Entity = UserSubmissionRecord ; const NAME : & 'static str = "UserSubmissionRecordBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . campaign_type_hash . as_slice () . len () + self . quest_id . as_slice () . len () + self . submission_timestamp . as_slice () . len () + self . submission_content . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . campaign_type_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . quest_id . as_slice () . len () ; offsets . push (total_size) ; total_size += self . submission_timestamp . as_slice () . len () ; offsets . push (total_size) ; total_size += self . submission_content . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . campaign_type_hash . as_slice ()) ? ; writer . write_all (self . quest_id . as_slice ()) ? ; writer . write_all (self . submission_timestamp . as_slice ()) ? ; writer . write_all (self . submission_content . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UserSubmissionRecord :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct UserSubmissionRecordVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UserSubmissionRecordVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UserSubmissionRecordVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UserSubmissionRecordVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for UserSubmissionRecordVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UserSubmissionRecordVec :: new_unchecked (v) } } impl UserSubmissionRecordVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UserSubmissionRecord > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UserSubmissionRecord { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UserSubmissionRecord :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UserSubmissionRecord :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> UserSubmissionRecordVecReader < 'r > { UserSubmissionRecordVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UserSubmissionRecordVec { type Builder = UserSubmissionRecordVecBuilder ; const NAME : & 'static str = "UserSubmissionRecordVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UserSubmissionRecordVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserSubmissionRecordVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserSubmissionRecordVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct UserSubmissionRecordVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UserSubmissionRecordVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UserSubmissionRecordVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UserSubmissionRecordVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > UserSubmissionRecordVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UserSubmissionRecordReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UserSubmissionRecordReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UserSubmissionRecordReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UserSubmissionRecordReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UserSubmissionRecordVecReader < 'r > { type Entity = UserSubmissionRecordVec ; const NAME : & 'static str = "UserSubmissionRecordVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UserSubmissionRecordVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; UserSubmissionRecordReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UserSubmissionRecordVecBuilder (pub (crate) Vec < UserSubmissionRecord >) ; impl UserSubmissionRecordVecBuilder { pub fn set (mut self , v : Vec < UserSubmissionRecord >) -> Self { self . 0 = v ; self } pub fn push < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UserSubmissionRecord > { self . 0 . push (v . into ()) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = UserSubmissionRecord >> (mut self , iter : T) -> Self { self . 0 . extend (iter) ; self } pub fn replace < T > (& mut self , index : usize , v : T) -> Option < UserSubmissionRecord > where T : :: core :: convert :: Into < UserSubmissionRecord > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v . into ())) } } impl molecule :: prelude :: Builder for UserSubmissionRecordVecBuilder { type Entity = UserSubmissionRecordVec ; const NAME : & 'static str = "UserSubmissionRecordVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UserSubmissionRecordVec :: new_unchecked (inner . into ()) } }
pub struct UserSubmissionRecordVecIterator (UserSubmissionRecordVec , usize , usize) ; impl :: core :: iter :: Iterator for UserSubmissionRecordVecIterator { type Item = UserSubmissionRecord ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for UserSubmissionRecordVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for UserSubmissionRecordVec { type Item = UserSubmissionRecord ; type IntoIter = UserSubmissionRecordVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; UserSubmissionRecordVecIterator (self , 0 , len) } } impl < 'r > UserSubmissionRecordVecReader < 'r > { pub fn iter < 't > (& 't self) -> UserSubmissionRecordVecReaderIterator < 't , 'r > { UserSubmissionRecordVecReaderIterator (& self , 0 , self . len ()) } } pub struct UserSubmissionRecordVecReaderIterator < 't , 'r > (& 't UserSubmissionRecordVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for UserSubmissionRecordVecReaderIterator < 't , 'r > { type Item = UserSubmissionRecordReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for UserSubmissionRecordVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < UserSubmissionRecord > for UserSubmissionRecordVec { fn from_iter < T : IntoIterator < Item = UserSubmissionRecord >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl From < Vec < UserSubmissionRecord >> for UserSubmissionRecordVec { fn from (v : Vec < UserSubmissionRecord >) -> Self { Self :: new_builder () . set (v) . build () } }
# [derive (Clone)] pub struct UserData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UserData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UserData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UserData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "verification_data" , self . verification_data ()) ? ; write ! (f , ", {}: {}" , "total_points_earned" , self . total_points_earned ()) ? ; write ! (f , ", {}: {}" , "last_activity_timestamp" , self . last_activity_timestamp ()) ? ; write ! (f , ", {}: {}" , "submission_records" , self . submission_records ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for UserData { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UserData :: new_unchecked (v) } } impl UserData { const DEFAULT_VALUE : [u8 ; 68] = [68 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 52 , 0 , 0 , 0 , 56 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn verification_data (& self) -> UserVerificationData { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; UserVerificationData :: new_unchecked (self . 0 . slice (start .. end)) } pub fn total_points_earned (& self) -> Uint32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn last_activity_timestamp (& self) -> Uint64 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn submission_records (& self) -> UserSubmissionRecordVec { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; UserSubmissionRecordVec :: new_unchecked (self . 0 . slice (start .. end)) } else { UserSubmissionRecordVec :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> UserDataReader < 'r > { UserDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UserData { type Builder = UserDataBuilder ; const NAME : & 'static str = "UserData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UserData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UserDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . verification_data (self . verification_data ()) . total_points_earned (self . total_points_earned ()) . last_activity_timestamp (self . last_activity_timestamp ()) . submission_records (self . submission_records ()) } }
# [derive (Clone , Copy)] pub struct UserDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UserDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UserDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UserDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "verification_data" , self . verification_data ()) ? ; write ! (f , ", {}: {}" , "total_points_earned" , self . total_points_earned ()) ? ; write ! (f , ", {}: {}" , "last_activity_timestamp" , self . last_activity_timestamp ()) ? ; write ! (f , ", {}: {}" , "submission_records" , self . submission_records ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > UserDataReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn verification_data (& self) -> UserVerificationDataReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; UserVerificationDataReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn total_points_earned (& self) -> Uint32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Uint32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn last_activity_timestamp (& self) -> Uint64Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Uint64Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn submission_records (& self) -> UserSubmissionRecordVecReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; UserSubmissionRecordVecReader :: new_unchecked (& self . as_slice () [start .. end]) } else { UserSubmissionRecordVecReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UserDataReader < 'r > { type Entity = UserData ; const NAME : & 'static str = "UserDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UserDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } UserVerificationDataReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Uint32Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Uint64Reader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; UserSubmissionRecordVecReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UserDataBuilder { pub (crate) verification_data : UserVerificationData , pub (crate) total_points_earned : Uint32 , pub (crate) last_activity_timestamp : Uint64 , pub (crate) submission_records : UserSubmissionRecordVec , } impl UserDataBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn verification_data < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UserVerificationData > { self . verification_data = v . into () ; self } pub fn total_points_earned < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint32 > { self . total_points_earned = v . into () ; self } pub fn last_activity_timestamp < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Uint64 > { self . last_activity_timestamp = v . into () ; self } pub fn submission_records < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < UserSubmissionRecordVec > { self . submission_records = v . into () ; self } } impl molecule :: prelude :: Builder for UserDataBuilder { type Entity = UserData ; const NAME : & 'static str = "UserDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . verification_data . as_slice () . len () + self . total_points_earned . as_slice () . len () + self . last_activity_timestamp . as_slice () . len () + self . submission_records . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . verification_data . as_slice () . len () ; offsets . push (total_size) ; total_size += self . total_points_earned . as_slice () . len () ; offsets . push (total_size) ; total_size += self . last_activity_timestamp . as_slice () . len () ; offsets . push (total_size) ; total_size += self . submission_records . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . verification_data . as_slice ()) ? ; writer . write_all (self . total_points_earned . as_slice ()) ? ; writer . write_all (self . last_activity_timestamp . as_slice ()) ? ; writer . write_all (self . submission_records . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UserData :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct ConnectedTypeID (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ConnectedTypeID { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ConnectedTypeID { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ConnectedTypeID { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "type_id" , self . type_id ()) ? ; write ! (f , ", {}: {}" , "connected_type_hash" , self . connected_type_hash ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ConnectedTypeID { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ConnectedTypeID :: new_unchecked (v) } } impl ConnectedTypeID { const DEFAULT_VALUE : [u8 ; 76] = [76 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 44 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn type_id (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn connected_type_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } else { Byte32 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ConnectedTypeIDReader < 'r > { ConnectedTypeIDReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ConnectedTypeID { type Builder = ConnectedTypeIDBuilder ; const NAME : & 'static str = "ConnectedTypeID" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ConnectedTypeID (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ConnectedTypeIDReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ConnectedTypeIDReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . type_id (self . type_id ()) . connected_type_hash (self . connected_type_hash ()) } }
# [derive (Clone , Copy)] pub struct ConnectedTypeIDReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ConnectedTypeIDReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ConnectedTypeIDReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ConnectedTypeIDReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "type_id" , self . type_id ()) ? ; write ! (f , ", {}: {}" , "connected_type_hash" , self . connected_type_hash ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ConnectedTypeIDReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn type_id (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn connected_type_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Byte32Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ConnectedTypeIDReader < 'r > { type Entity = ConnectedTypeID ; const NAME : & 'static str = "ConnectedTypeIDReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ConnectedTypeIDReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte32Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ConnectedTypeIDBuilder { pub (crate) type_id : Byte32 , pub (crate) connected_type_hash : Byte32 , } impl ConnectedTypeIDBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn type_id < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . type_id = v . into () ; self } pub fn connected_type_hash < T > (mut self , v : T) -> Self where T : :: core :: convert :: Into < Byte32 > { self . connected_type_hash = v . into () ; self } } impl molecule :: prelude :: Builder for ConnectedTypeIDBuilder { type Entity = ConnectedTypeID ; const NAME : & 'static str = "ConnectedTypeIDBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . type_id . as_slice () . len () + self . connected_type_hash . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . type_id . as_slice () . len () ; offsets . push (total_size) ; total_size += self . connected_type_hash . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . type_id . as_slice ()) ? ; writer . write_all (self . connected_type_hash . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ConnectedTypeID :: new_unchecked (inner . into ()) } }
