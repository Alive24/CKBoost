option CellDepVecOpt (CellDepVec);
option Byte32VecOpt (Byte32Vec);

// Recipe argument that can contain either inline data or a reference to data
table RecipeArgument {
    arg_type: byte,               // 0 = inline_data
                                  // 1 = input_data_reference (index into inputs for cell data) - matches Source::Input
                                  // 2 = output_data_reference (index into outputs_data) - matches Source::Output
                                  // 3 = cell_dep_data_reference (index into cell_deps for dep cell data) - matches Source::CellDep
                                  // 4 = header_reference (index into header_deps) - matches Source::HeaderDep
    data: Bytes,                  // For inline_data: the actual data
                                  // For references: 4-byte LE index into the corresponding vector
}

vector RecipeArgumentVec <RecipeArgument>;

// Transaction Recipe Schema for SSRI - Generic for all CKB projects
table TransactionRecipe {
    method_path: Bytes,           // The method path (e.g., b"UDT.transfer", b"AMM.swap")
    arguments: RecipeArgumentVec, // Structured arguments for the method
    cell_deps: CellDepVecOpt,     // Optional cell dependencies
    header_deps: Byte32VecOpt,    // Optional header dependencies
}

option Byte32Opt (Byte32);
vector ScriptVec <Script>;
vector Uint128Vec <Uint128>;
array Uint8 [byte; 1];
vector Uint8Vec <Uint8>;
vector String <byte>;
vector StringVec <String>;


table UDTAsset {
    udt_script: Script,
    amount: Uint128,
}

vector UDTAssetVec <UDTAsset>;

// Campaign funding information
table AssetList {
    points_amount: Uint64,      // Total points target for the campaign
    ckb_amount: Uint64,        // Total funding target for the campaign
    nft_assets: ScriptVec,     // NFT assets to be managed by campaign
    udt_assets: UDTAssetVec, // UDT assets to be managed by campaign
}

vector AssetListVec <AssetList>;

table QuestSubTaskData {
    id: Uint8,
    title: String,
    type: String, // text, link, txhash. More types can be added in the future.
    description: String,
    proof_required: String, // Description of required proof
}

vector QuestSubTaskDataVec <QuestSubTaskData>;

table QuestMetadata {
    title: String,
    short_description: String,
    long_description: String,
    requirements: String,
    difficulty: Uint8,            // 0=easy, 1=medium, 2=hard
    time_estimate: Uint32,        // Estimated time in minutes
}

table QuestData {
    quest_id: Uint32,
    metadata: QuestMetadata,
    rewards_on_completion: AssetListVec,
    accepted_submission_user_type_ids: Byte32Vec,
    completion_deadline: Uint64,  // Optional deadline for quest completion
    status: byte,                 // 0=created, 1=active, 2=completed, 3=cancelled
    sub_tasks: QuestSubTaskDataVec,
    points: Uint32,               // Quest points/rewards
    completion_count: Uint32,     // Total number of completions
}

vector QuestDataVec <QuestData>;

table CampaignMetadata {
    title: String,
    endorser_info: EndorserInfo,
    short_description: String,     // For campaign cards
    long_description: String,      // For detail pages
    total_rewards: AssetList,
    verification_requirements: Uint8Vec, // Bitmask: telegram(1), kyc(2), did(4), manual_review(8), twitter(16), discord(32), reddit(64)
    last_updated: Uint64,
    categories: StringVec,         // e.g., ["DeFi", "Gaming", "Social"]
    difficulty: Uint8,            // Overall campaign difficulty
    image_url: String,            
}

table CampaignData {
    endorser: EndorserInfo,
    created_at: Uint64,
    starting_time: Uint64,
    ending_time: Uint64,
    rules: StringVec,             // Campaign-specific rules
    metadata: CampaignMetadata,
    quests: QuestDataVec,
    participants_count: Uint32,
    total_completions: Uint32,    // Total quest completions across all participants
}

vector CampaignDataVec <CampaignData>;

// Schemas for CKBoost Protocol Data

table TippingProposalMetadata {
    contribution_title: String,
    contribution_type_tags: StringVec,
    description: String,
    proposal_creation_timestamp: Uint64,
}

table TippingProposalData {
    target_address: String,
    proposer_lock_hash: Byte32,
    metadata: TippingProposalMetadata,
    amount: Uint64,
    tipping_transaction_hash: Byte32Opt, 
    approval_transaction_hash: Byte32Vec, 
}

vector TippingProposalDataVec <TippingProposalData>;

table EndorserInfo {
    endorser_lock_hash: Byte32,
    endorser_name: String,
    endorser_description: String,
    website: String,
    social_links: StringVec,  // Array of social media links
    verified: Uint8,         // Verification status (0=unverified, 1=verified)
}

vector EndorserInfoVec <EndorserInfo>;

table TippingConfig {
    approval_requirement_thresholds: Uint128Vec, // e.g. [10000, 50000, 100000] means it takes 3 approvals for 10000, 4 approvals for 50000, 5 approvals for 100000. Can add more thresholds in the future. Minimum approval threshold is 3.
    expiration_duration: Uint64, // The duration of the proposal in seconds since creation.
}

table ScriptCodeHashes {
    ckb_boost_protocol_type_code_hash: Byte32,
    ckb_boost_protocol_lock_code_hash: Byte32,
    ckb_boost_campaign_type_code_hash: Byte32,
    ckb_boost_campaign_lock_code_hash: Byte32,
    ckb_boost_user_type_code_hash: Byte32,
    ckb_boost_points_udt_code_hash: Byte32,
    accepted_udt_type_scripts: ScriptVec,
    accepted_dob_type_scripts: ScriptVec,
}

table ProtocolConfig {
    admin_lock_hash_vec: Byte32Vec,
    script_code_hashes: ScriptCodeHashes,
}

table ProtocolData {
    campaigns_approved: Byte32Vec,
    tipping_proposals: TippingProposalDataVec,
    tipping_config: TippingConfig,
    endorsers_whitelist: EndorserInfoVec,
    last_updated: Uint64,
    protocol_config: ProtocolConfig,
}

table UserVerificationData {
    telegram_personal_chat_id: Uint128,
    identity_verification_data: Bytes, // TODO: Leave this part agnostic for now
}

table UserSubmissionRecord {
    campaign_type_id: Byte32,
    quest_id: Uint32,
    submission_timestamp: Uint64,
    submission_content: String,
}

vector UserSubmissionRecordVec <UserSubmissionRecord>;

table UserData {
    verification_data: UserVerificationData,
    total_points_earned: Uint32,
    last_activity_timestamp: Uint64,
    submission_records: UserSubmissionRecordVec,
}


table ConnectedTypeID {
    type_id: Byte32,
    connected_key: Byte32,
}


