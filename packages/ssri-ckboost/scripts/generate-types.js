#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

function generateTypeScript(jsonSchema) {
  let schema;
  try {
    schema = JSON.parse(jsonSchema);
  } catch (error) {
    throw new Error(`Failed to parse JSON schema: ${error.message}`);
  }

  // Validate schema structure
  if (!schema.declarations || !Array.isArray(schema.declarations)) {
    throw new Error('Invalid schema: missing or invalid declarations array');
  }
  
  let output = `// Auto-generated TypeScript definitions for CKBoost molecule schema
// Do not edit this file manually - it will be overwritten

export interface CastToArrayBuffer {
  toArrayBuffer(): ArrayBuffer;
}

export type CanCastToArrayBuffer = ArrayBuffer | CastToArrayBuffer;

export interface CreateOptions {
  validate?: boolean;
}

export interface UnionType {
  type: string;
  value: any;
}

`;

  // Dynamically determine basic types from schema instead of hardcoding
  const basicTypes = new Set();
  const knownBasicTypes = ['Uint32', 'Uint64', 'Uint128', 'Byte32', 'Uint256', 'Bytes', 'Uint8', 'Uint16'];
  
  schema.declarations.forEach(decl => {
    if (decl.type === 'array' && knownBasicTypes.includes(decl.name)) {
      basicTypes.add(decl.name);
    }
  });
  
  // Generate type aliases with better error handling
  schema.declarations.forEach(decl => {
    try {
      if (!decl.name) {
        console.warn('Warning: Declaration missing name:', decl);
        return;
      }

      if (decl.type === 'array') {
        output += `export type ${decl.name}Type = CanCastToArrayBuffer;\n`;
      } else if (decl.type === 'fixvec' && decl.name === 'Bytes') {
        output += `export type BytesType = CanCastToArrayBuffer;\n`;
      } else if (decl.type === 'option') {
        const itemType = decl.item === 'Bytes' ? 'BytesType' : 
                        decl.item ? `${decl.item}Type` : 'any';
        output += `export type ${decl.name}Type = ${itemType} | undefined;\n`;
      } else if (decl.type === 'dynvec' || decl.type === 'fixvec') {
        const itemType = decl.item === 'byte' ? 'number' : 
                        basicTypes.has(decl.item) ? `${decl.item}Type` : 
                        decl.item ? `${decl.item}Type` : 'any';
        output += `export type ${decl.name}Type = ${itemType}[];\n`;
      }
    } catch (error) {
      console.warn(`Warning: Failed to generate type alias for ${decl.name}:`, error.message);
    }
  });

  output += '\n';

  // Generate interfaces for structs and tables with error handling
  schema.declarations.forEach(decl => {
    try {
      if (!decl.name) return;
      
      if (decl.type === 'struct' || decl.type === 'table') {
        output += `export interface ${decl.name}Type {\n`;
        
        if (decl.fields && Array.isArray(decl.fields)) {
          decl.fields.forEach(field => {
            try {
              if (field.name && field.type) {
                const fieldType = getFieldType(field.type, basicTypes);
                output += `  ${field.name}: ${fieldType};\n`;
              }
            } catch (error) {
              console.warn(`Warning: Failed to generate field ${field.name} for ${decl.name}:`, error.message);
              output += `  ${field.name || 'unknown'}: any; // Error: ${error.message}\n`;
            }
          });
        } else {
          console.warn(`Warning: ${decl.name} has no fields or invalid fields structure`);
        }
        
        output += '}\n\n';
      }
    } catch (error) {
      console.warn(`Warning: Failed to generate interface for ${decl.name}:`, error.message);
    }
  });

  // Generate class declarations with error handling
  schema.declarations.forEach(decl => {
    try {
      if (!decl.name) return;
      
      const className = decl.name;
      
      output += `export declare class ${className} {\n`;
      output += `  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);\n`;
      output += `  validate(compatible?: boolean): void;\n`;
      
      if (decl.type === 'struct' || decl.type === 'table') {
        if (decl.fields && Array.isArray(decl.fields)) {
          decl.fields.forEach(field => {
            try {
              if (field.name && field.type) {
                const returnType = getFieldType(field.type, basicTypes, true);
                const methodName = 'get' + field.name.split('_').map(word => 
                  word.charAt(0).toUpperCase() + word.slice(1)).join('');
                output += `  ${methodName}(): ${returnType};\n`;
              }
            } catch (error) {
              console.warn(`Warning: Failed to generate method for field ${field.name}:`, error.message);
            }
          });
        }
      } else if (decl.type === 'dynvec' || decl.type === 'fixvec') {
        output += `  length(): number;\n`;
        const itemReturnType = basicTypes.has(decl.item) ? decl.item : 
                             decl.item === 'byte' ? 'number' : 
                             decl.item || 'any';
        output += `  indexAt(i: number): ${itemReturnType};\n`;
      } else if (decl.type === 'array') {
        output += `  raw(): Uint8Array;\n`;
      } else if (decl.type === 'option') {
        const itemType = basicTypes.has(decl.item) ? decl.item : decl.item || 'any';
        output += `  hasValue(): boolean;\n`;
        output += `  value(): ${itemType} | undefined;\n`;
      }
      
      output += '}\n\n';
    } catch (error) {
      console.warn(`Warning: Failed to generate class for ${decl.name}:`, error.message);
    }
  });

  return output;
}

function getFieldType(type, basicTypes, forClass = false) {
  if (type === 'byte') {
    return 'number';
  } else if (basicTypes.has(type)) {
    return forClass ? type : `${type}Type`;
  } else if (type.endsWith('Opt')) {
    const baseType = type.slice(0, -3);
    return forClass ? `${baseType} | undefined` : `${type}Type`;
  } else if (type.endsWith('Vec')) {
    const baseType = type.slice(0, -3);
    return forClass ? baseType : `${type}Type`;
  } else {
    return forClass ? type : `${type}Type`;
  }
}

function generateIndexFile(jsonSchema) {
  let schema;
  try {
    schema = JSON.parse(jsonSchema);
  } catch (error) {
    throw new Error(`Failed to parse JSON schema for index generation: ${error.message}`);
  }

  if (!schema.declarations || !Array.isArray(schema.declarations)) {
    throw new Error('Invalid schema for index generation: missing declarations array');
  }
  
  let output = `// Auto-generated exports for CKBoost molecule schema
// This file re-exports the JavaScript implementation with TypeScript types

// Export all TypeScript types
export type * from './ckboost';

// Export the JavaScript implementation (runtime classes)
// Note: We need to be careful about module/CommonJS compatibility
const ckboost = require('./ckboost-cjs.js');

// Re-export all JavaScript classes
export const {
`;

  // Add all the class exports from the schema with error handling
  const validDeclarations = schema.declarations.filter(decl => {
    if (!decl.name) {
      console.warn('Warning: Skipping declaration without name:', decl);
      return false;
    }
    return true;
  });

  validDeclarations.forEach((decl, index) => {
    const isLast = index === validDeclarations.length - 1;
    output += `  ${decl.name}${isLast ? '' : ','}\n`;
  });

  output += `} = ckboost;

// Export all serialize/deserialize functions
export const {`;

  // Get all the serialize functions from the JavaScript file with error handling
  // Updated path for SDK structure
  const jsPath = path.join(__dirname, '../src/generated/ckboost.js');
  let functionNames = [];
  
  try {
    if (fs.existsSync(jsPath)) {
      const jsContent = fs.readFileSync(jsPath, 'utf8');
      const functionMatches = jsContent.match(/export function (Serialize\w+|Deserialize\w+)/g) || [];
      functionNames = functionMatches.map(match => match.replace('export function ', ''));
      
      if (functionNames.length === 0) {
        console.warn('Warning: No serialize/deserialize functions found in generated JS file');
      }
    } else {
      console.warn(`Warning: Generated JS file not found at ${jsPath}`);
    }
  } catch (error) {
    console.warn(`Warning: Failed to read serialize functions: ${error.message}`);
  }
  
  functionNames.forEach((funcName, index) => {
    const isLast = index === functionNames.length - 1;
    output += `\n  ${funcName}${isLast ? '' : ','}`; 
  });

  output += `\n} = ckboost;

// Default export for convenience
export default ckboost;
`;

  return output;
}

function generateCommonJSWrapper() {
  const wrapperContent = `// CommonJS wrapper for the ES module ckboost.js
// This file provides CommonJS compatibility for Jest and other tools

// Read the ES module file and convert exports to CommonJS
const fs = require('fs');
const path = require('path');
const vm = require('vm');

// Read the ES module source
const esModuleSource = fs.readFileSync(path.join(__dirname, 'ckboost.js'), 'utf8');

// Create a module context
const moduleExports = {};
const moduleContext = {
  exports: moduleExports,
  module: { exports: moduleExports },
  require: require,
  __dirname: __dirname,
  __filename: __filename,
  console: console,
  process: process,
  Buffer: Buffer,
  ArrayBuffer: ArrayBuffer,
  Uint8Array: Uint8Array,
  DataView: DataView,
  Error: Error,
  Object: Object,
  Function: Function,
  Number: Number,
  Boolean: Boolean,
  String: String,
  Array: Array
};

// Convert ES module exports to CommonJS
const cjsSource = esModuleSource
  .replace(/export\\s+class\\s+(\\w+)/g, 'class $1')
  .replace(/export\\s+function\\s+(\\w+)/g, 'function $1')
  .replace(/export\\s+(?:const|let|var)\\s+(\\w+)/g, 'const $1')
  .replace(/export\\s*\\{([^}]+)\\}/g, '');

// Add exports at the end
const exportStatements = [];
const classMatches = esModuleSource.match(/export\\s+class\\s+(\\w+)/g) || [];
const functionMatches = esModuleSource.match(/export\\s+function\\s+(\\w+)/g) || [];

classMatches.forEach(match => {
  const className = match.replace(/export\\s+class\\s+/, '');
  exportStatements.push(\`exports.\${className} = \${className};\`);
});

functionMatches.forEach(match => {
  const funcName = match.replace(/export\\s+function\\s+/, '');
  exportStatements.push(\`exports.\${funcName} = \${funcName};\`);
});

// Create the final CommonJS module
const finalSource = cjsSource + '\\n\\n' + exportStatements.join('\\n');

// Execute in VM context
try {
  vm.runInNewContext(finalSource, moduleContext);
  
  // Export everything from the module
  Object.assign(exports, moduleContext.exports);
} catch (error) {
  console.error('Failed to load ckboost.js as CommonJS:', error);
  throw error;
}
`;
  return wrapperContent;
}

// Main execution with comprehensive error handling
function main() {
  // Updated paths for SDK structure
  const jsonPath = path.join(__dirname, '../src/generated/ckboost.json');
  const outputPath = path.join(__dirname, '../src/generated/ckboost.d.ts');
  const indexPath = path.join(__dirname, '../src/generated/index.ts');

  try {
    // Check if input file exists
    if (!fs.existsSync(jsonPath)) {
      throw new Error('ckboost.json not found. Run molecule generation first.');
    }

    // Create backup of existing generated files
    const backupFiles = [outputPath, indexPath].filter(fs.existsSync);
    const backups = backupFiles.map(file => {
      const backupPath = file + '.backup';
      try {
        fs.copyFileSync(file, backupPath);
        return { original: file, backup: backupPath };
      } catch (error) {
        console.warn(`Warning: Could not backup ${file}: ${error.message}`);
        return null;
      }
    }).filter(Boolean);

    // Read and validate JSON content
    let jsonContent;
    try {
      jsonContent = fs.readFileSync(jsonPath, 'utf8');
      if (!jsonContent.trim()) {
        throw new Error('ckboost.json is empty');
      }
    } catch (error) {
      throw new Error(`Failed to read ckboost.json: ${error.message}`);
    }

    // Parse and validate schema first
    let schema;
    try {
      schema = JSON.parse(jsonContent);
      validateMoleculeTypes(schema);
    } catch (error) {
      throw new Error(`Invalid molecule schema: ${error.message}`);
    }

    // Generate TypeScript declarations
    console.log('Generating TypeScript declarations...');
    try {
      const typeScript = generateTypeScript(jsonContent);
      fs.writeFileSync(outputPath, typeScript);
      console.log(`✓ Generated ${outputPath}`);
    } catch (error) {
      throw new Error(`Failed to generate TypeScript declarations: ${error.message}`);
    }

    // Generate index file
    console.log('Generating index file...');
    try {
      const indexContent = generateIndexFile(jsonContent);
      fs.writeFileSync(indexPath, indexContent);
      console.log(`✓ Generated ${indexPath}`);
    } catch (error) {
      throw new Error(`Failed to generate index file: ${error.message}`);
    }

    // Generate CommonJS wrapper
    console.log('Generating CommonJS wrapper...');
    try {
      const wrapperPath = path.join(__dirname, '../src/generated/ckboost-cjs.js');
      const wrapperContent = generateCommonJSWrapper();
      fs.writeFileSync(wrapperPath, wrapperContent);
      console.log(`✓ Generated ${wrapperPath}`);
    } catch (error) {
      throw new Error(`Failed to generate CommonJS wrapper: ${error.message}`);
    }

    console.log('✅ TypeScript declarations, index file, and CommonJS wrapper generated successfully!');
    
    // Validate generated files
    console.log('Validating generated files...');
    const wrapperPath = path.join(__dirname, '../src/generated/ckboost-cjs.js');
    if (!fs.existsSync(outputPath) || !fs.existsSync(indexPath) || !fs.existsSync(wrapperPath)) {
      console.warn('⚠️  Warning: Some generated files are missing');
    } else {
      console.log('✓ All files generated successfully');
    }

    // Clean up backup files on success
    backups.forEach(({ backup }) => {
      try {
        fs.unlinkSync(backup);
      } catch (error) {
        console.warn(`Warning: Could not clean up backup ${backup}`);
      }
    });

  } catch (error) {
    console.error('❌ Generation failed:', error.message);
    
    // Attempt to restore from backups
    if (backups && backups.length > 0) {
      console.log('\n🔄 Attempting to restore from backups...');
      let restored = false;
      backups.forEach(({ original, backup }) => {
        try {
          fs.copyFileSync(backup, original);
          console.log(`✓ Restored ${original}`);
          restored = true;
        } catch (restoreError) {
          console.warn(`Warning: Could not restore ${original}: ${restoreError.message}`);
        }
      });
      
      if (restored) {
        console.log('✓ Previous files restored successfully');
      }
    }
    
    // Provide helpful troubleshooting info
    console.error('\n🔧 Troubleshooting:');
    console.error('1. Ensure moleculec and moleculec-es ran successfully');
    console.error('2. Check that ckboost.json was generated correctly');
    console.error('3. Verify the molecule schema syntax is valid');
    console.error('4. Check file permissions in src/generated directory');
    console.error('5. Try running npm run generate again');
    
    process.exit(1);
  }
}

// Add a safety check for unknown molecule types
function validateMoleculeTypes(schema) {
  const supportedTypes = ['array', 'fixvec', 'dynvec', 'option', 'struct', 'table', 'union'];
  const unknownTypes = [];
  
  schema.declarations.forEach(decl => {
    if (decl.type && !supportedTypes.includes(decl.type)) {
      unknownTypes.push({ name: decl.name, type: decl.type });
    }
  });
  
  if (unknownTypes.length > 0) {
    console.warn('⚠️  Warning: Unknown molecule types detected:');
    unknownTypes.forEach(({ name, type }) => {
      console.warn(`  - ${name}: ${type}`);
    });
    console.warn('These types may not generate correctly. Consider updating the generator.');
  }
}

// Run main function
main();