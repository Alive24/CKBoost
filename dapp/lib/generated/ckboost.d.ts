// Auto-generated TypeScript definitions for CKBoost molecule schema
// Do not edit this file manually - it will be overwritten

export interface CastToArrayBuffer {
  toArrayBuffer(): ArrayBuffer;
}

export type CanCastToArrayBuffer = ArrayBuffer | CastToArrayBuffer;

export interface CreateOptions {
  validate?: boolean;
}

export interface UnionType {
  type: string;
  value: any;
}

export type Uint32Type = CanCastToArrayBuffer;
export type Uint64Type = CanCastToArrayBuffer;
export type Uint128Type = CanCastToArrayBuffer;
export type Byte32Type = CanCastToArrayBuffer;
export type Uint256Type = CanCastToArrayBuffer;
export type BytesType = CanCastToArrayBuffer;
export type BytesOptType = BytesType | undefined;
export type BytesOptVecType = BytesOptType[];
export type BytesVecType = BytesType[];
export type Byte32VecType = Byte32Type[];
export type ScriptOptType = ScriptType | undefined;
export type ProposalShortIdType = CanCastToArrayBuffer;
export type UncleBlockVecType = UncleBlockType[];
export type TransactionVecType = TransactionType[];
export type ProposalShortIdVecType = ProposalShortIdType[];
export type CellDepVecType = CellDepType[];
export type CellInputVecType = CellInputType[];
export type CellOutputVecType = CellOutputType[];
export type Byte32OptType = Byte32Type | undefined;
export type ScriptVecType = ScriptType[];
export type Uint128VecType = Uint128Type[];
export type Uint8Type = CanCastToArrayBuffer;
export type UDTFundingVecType = UDTFundingType[];
export type AssetListVecType = AssetListType[];
export type QuestSubTaskDataVecType = QuestSubTaskDataType[];
export type CompletionRecordVecType = CompletionRecordType[];
export type QuestDataVecType = QuestDataType[];
export type CampaignDataVecType = CampaignDataType[];
export type TippingProposalDataVecType = TippingProposalDataType[];
export type EndorserInfoVecType = EndorserInfoType[];

export interface ScriptType {
  code_hash: Byte32Type;
  hash_type: number;
  args: BytesType;
}

export interface OutPointType {
  tx_hash: Byte32Type;
  index: Uint32Type;
}

export interface CellInputType {
  since: Uint64Type;
  previous_output: OutPointType;
}

export interface CellOutputType {
  capacity: Uint64Type;
  lock: ScriptType;
  type_: ScriptOptType;
}

export interface CellDepType {
  out_point: OutPointType;
  dep_type: number;
}

export interface RawTransactionType {
  version: Uint32Type;
  cell_deps: CellDepVecType;
  header_deps: Byte32VecType;
  inputs: CellInputVecType;
  outputs: CellOutputVecType;
  outputs_data: BytesVecType;
}

export interface TransactionType {
  raw: RawTransactionType;
  witnesses: BytesVecType;
}

export interface RawHeaderType {
  version: Uint32Type;
  compact_target: Uint32Type;
  timestamp: Uint64Type;
  number: Uint64Type;
  epoch: Uint64Type;
  parent_hash: Byte32Type;
  transactions_root: Byte32Type;
  proposals_hash: Byte32Type;
  extra_hash: Byte32Type;
  dao: Byte32Type;
}

export interface HeaderType {
  raw: RawHeaderType;
  nonce: Uint128Type;
}

export interface UncleBlockType {
  header: HeaderType;
  proposals: ProposalShortIdVecType;
}

export interface BlockType {
  header: HeaderType;
  uncles: UncleBlockVecType;
  transactions: TransactionVecType;
  proposals: ProposalShortIdVecType;
}

export interface BlockV1Type {
  header: HeaderType;
  uncles: UncleBlockVecType;
  transactions: TransactionVecType;
  proposals: ProposalShortIdVecType;
  extension: BytesType;
}

export interface CellbaseWitnessType {
  lock: ScriptType;
  message: BytesType;
}

export interface WitnessArgsType {
  lock: BytesOptType;
  input_type: BytesOptType;
  output_type: BytesOptType;
}

export interface UDTFundingType {
  udt_script: ScriptType;
  amount: Uint128Type;
}

export interface AssetListType {
  ckb_amount: Uint64Type;
  nft_assets: ScriptVecType;
  udt_assets: UDTFundingVecType;
}

export interface QuestSubTaskDataType {
  id: Uint8Type;
  title: BytesType;
  type: BytesType;
  description: BytesType;
}

export interface CompletionRecordType {
  user_address: BytesType;
  sub_task_id: Uint8Type;
  completion_timestamp: Uint64Type;
  completion_content: BytesType;
}

export interface QuestDataType {
  id: Byte32Type;
  campaign_id: Byte32Type;
  requirements: BytesType;
  rewards_on_completion: AssetListVecType;
  completion_records: CompletionRecordVecType;
  completion_deadline: Uint64Type;
  status: number;
  sub_tasks: QuestSubTaskDataVecType;
}

export interface CampaignMetadataType {
  funding_info: AssetListVecType;
  created_at: Uint64Type;
  starting_time: Uint64Type;
  ending_time: Uint64Type;
  verification_requirements: number;
  last_updated: Uint64Type;
}

export interface CampaignDataType {
  id: Byte32Type;
  creator: ScriptType;
  metadata: CampaignMetadataType;
  status: number;
  quests: QuestDataVecType;
}

export interface UserVerificationDataType {
  user_address: BytesType;
  telegram_personal_chat_id: Uint128Type;
  identity_verification_data: BytesType;
}

export interface TippingProposalMetadataType {
  contribution_title: BytesType;
  contribution_type_tags: BytesVecType;
  description: BytesType;
  proposal_creation_timestamp: Uint64Type;
}

export interface TippingProposalDataType {
  target_address: BytesType;
  proposer_lock_hash: Byte32Type;
  metadata: TippingProposalMetadataType;
  amount: Uint64Type;
  tipping_transaction_hash: Byte32OptType;
  approval_transaction_hash: Byte32VecType;
}

export interface EndorserInfoType {
  endorser_lock_hash: Byte32Type;
  endorser_name: BytesType;
  endorser_description: BytesType;
}

export interface TippingConfigType {
  approval_requirement_thresholds: Uint128VecType;
  expiration_duration: Uint64Type;
}

export interface ScriptCodeHashesType {
  ckb_boost_protocol_type_code_hash: Byte32Type;
  ckb_boost_protocol_lock_code_hash: Byte32Type;
  ckb_boost_campaign_type_code_hash: Byte32Type;
  ckb_boost_campaign_lock_code_hash: Byte32Type;
  ckb_boost_user_type_code_hash: Byte32Type;
}

export interface ProtocolConfigType {
  admin_lock_hash_vec: Byte32VecType;
  script_code_hashes: ScriptCodeHashesType;
}

export interface ProtocolDataType {
  campaigns_approved: CampaignDataVecType;
  tipping_proposals: TippingProposalDataVecType;
  tipping_config: TippingConfigType;
  endorsers_whitelist: EndorserInfoVecType;
  last_updated: Uint64Type;
  protocol_config: ProtocolConfigType;
}

export declare class Uint32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class Uint64 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class Uint128 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class Byte32 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class Uint256 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class Bytes {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): number;
}

export declare class BytesOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  hasValue(): boolean;
  value(): Bytes | undefined;
}

export declare class BytesOptVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): BytesOpt;
}

export declare class BytesVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): Bytes;
}

export declare class Byte32Vec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): Byte32;
}

export declare class ScriptOpt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  hasValue(): boolean;
  value(): Script | undefined;
}

export declare class ProposalShortId {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class UncleBlockVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): UncleBlock;
}

export declare class TransactionVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): Transaction;
}

export declare class ProposalShortIdVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): ProposalShortId;
}

export declare class CellDepVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): CellDep;
}

export declare class CellInputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): CellInput;
}

export declare class CellOutputVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): CellOutput;
}

export declare class Script {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCodeHash(): Byte32;
  getHashType(): number;
  getArgs(): Bytes;
}

export declare class OutPoint {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getTxHash(): Byte32;
  getIndex(): Uint32;
}

export declare class CellInput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getSince(): Uint64;
  getPreviousOutput(): OutPoint;
}

export declare class CellOutput {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCapacity(): Uint64;
  getLock(): Script;
  getType(): Script | undefined;
}

export declare class CellDep {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getOutPoint(): OutPoint;
  getDepType(): number;
}

export declare class RawTransaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getVersion(): Uint32;
  getCellDeps(): CellDep;
  getHeaderDeps(): Byte32;
  getInputs(): CellInput;
  getOutputs(): CellOutput;
  getOutputsData(): Bytes;
}

export declare class Transaction {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRaw(): RawTransaction;
  getWitnesses(): Bytes;
}

export declare class RawHeader {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getVersion(): Uint32;
  getCompactTarget(): Uint32;
  getTimestamp(): Uint64;
  getNumber(): Uint64;
  getEpoch(): Uint64;
  getParentHash(): Byte32;
  getTransactionsRoot(): Byte32;
  getProposalsHash(): Byte32;
  getExtraHash(): Byte32;
  getDao(): Byte32;
}

export declare class Header {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getRaw(): RawHeader;
  getNonce(): Uint128;
}

export declare class UncleBlock {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getProposals(): ProposalShortId;
}

export declare class Block {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getUncles(): UncleBlock;
  getTransactions(): Transaction;
  getProposals(): ProposalShortId;
}

export declare class BlockV1 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getHeader(): Header;
  getUncles(): UncleBlock;
  getTransactions(): Transaction;
  getProposals(): ProposalShortId;
  getExtension(): Bytes;
}

export declare class CellbaseWitness {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Script;
  getMessage(): Bytes;
}

export declare class WitnessArgs {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getLock(): Bytes | undefined;
  getInputType(): Bytes | undefined;
  getOutputType(): Bytes | undefined;
}

export declare class Byte32Opt {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  hasValue(): boolean;
  value(): Byte32 | undefined;
}

export declare class ScriptVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): Script;
}

export declare class Uint128Vec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): Uint128;
}

export declare class Uint8 {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  raw(): Uint8Array;
}

export declare class UDTFunding {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getUdtScript(): Script;
  getAmount(): Uint128;
}

export declare class UDTFundingVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): UDTFunding;
}

export declare class AssetList {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCkbAmount(): Uint64;
  getNftAssets(): Script;
  getUdtAssets(): UDTFunding;
}

export declare class AssetListVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): AssetList;
}

export declare class QuestSubTaskData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getId(): Uint8;
  getTitle(): Bytes;
  getType(): Bytes;
  getDescription(): Bytes;
}

export declare class QuestSubTaskDataVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): QuestSubTaskData;
}

export declare class CompletionRecord {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getUserAddress(): Bytes;
  getSubTaskId(): Uint8;
  getCompletionTimestamp(): Uint64;
  getCompletionContent(): Bytes;
}

export declare class CompletionRecordVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): CompletionRecord;
}

export declare class QuestData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getId(): Byte32;
  getCampaignId(): Byte32;
  getRequirements(): Bytes;
  getRewardsOnCompletion(): AssetList;
  getCompletionRecords(): CompletionRecord;
  getCompletionDeadline(): Uint64;
  getStatus(): number;
  getSubTasks(): QuestSubTaskData;
}

export declare class QuestDataVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): QuestData;
}

export declare class CampaignMetadata {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getFundingInfo(): AssetList;
  getCreatedAt(): Uint64;
  getStartingTime(): Uint64;
  getEndingTime(): Uint64;
  getVerificationRequirements(): number;
  getLastUpdated(): Uint64;
}

export declare class CampaignData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getId(): Byte32;
  getCreator(): Script;
  getMetadata(): CampaignMetadata;
  getStatus(): number;
  getQuests(): QuestData;
}

export declare class CampaignDataVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): CampaignData;
}

export declare class UserVerificationData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getUserAddress(): Bytes;
  getTelegramPersonalChatId(): Uint128;
  getIdentityVerificationData(): Bytes;
}

export declare class TippingProposalMetadata {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getContributionTitle(): Bytes;
  getContributionTypeTags(): Bytes;
  getDescription(): Bytes;
  getProposalCreationTimestamp(): Uint64;
}

export declare class TippingProposalData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getTargetAddress(): Bytes;
  getProposerLockHash(): Byte32;
  getMetadata(): TippingProposalMetadata;
  getAmount(): Uint64;
  getTippingTransactionHash(): Byte32 | undefined;
  getApprovalTransactionHash(): Byte32;
}

export declare class TippingProposalDataVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): TippingProposalData;
}

export declare class EndorserInfo {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getEndorserLockHash(): Byte32;
  getEndorserName(): Bytes;
  getEndorserDescription(): Bytes;
}

export declare class EndorserInfoVec {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  length(): number;
  indexAt(i: number): EndorserInfo;
}

export declare class TippingConfig {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getApprovalRequirementThresholds(): Uint128;
  getExpirationDuration(): Uint64;
}

export declare class ScriptCodeHashes {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCkbBoostProtocolTypeCodeHash(): Byte32;
  getCkbBoostProtocolLockCodeHash(): Byte32;
  getCkbBoostCampaignTypeCodeHash(): Byte32;
  getCkbBoostCampaignLockCodeHash(): Byte32;
  getCkbBoostUserTypeCodeHash(): Byte32;
}

export declare class ProtocolConfig {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getAdminLockHashVec(): Byte32;
  getScriptCodeHashes(): ScriptCodeHashes;
}

export declare class ProtocolData {
  constructor(reader: CanCastToArrayBuffer, options?: CreateOptions);
  validate(compatible?: boolean): void;
  getCampaignsApproved(): CampaignData;
  getTippingProposals(): TippingProposalData;
  getTippingConfig(): TippingConfig;
  getEndorsersWhitelist(): EndorserInfo;
  getLastUpdated(): Uint64;
  getProtocolConfig(): ProtocolConfig;
}

